// ** Bitmap Classes ** //
// Autogenerated in QDP Commands ** //
// Manzano Software //

#ifndef _MZN_CMD_FIELD_BITMAP_TYPES_H
#define _MZN_CMD_FIELD_BITMAP_TYPES_H

#include "cmd_field_bitmap.h"

namespace mzn {

class BmAdcmodel : public CmdFieldBitmap<1> {
friend std::ostream & operator<<(std::ostream & bm_os, BmAdcmodel const & bm);

public:
    explicit BmAdcmodel() : CmdFieldBitmap<1>{} {};

    enum class AdcModel {
        no_adc_module_installed = 0,
        one_channel_adc_module_configured_for_setra_use = 1,
        generic_one_channel_adc_module = 2,
        generic_three_adc_module = 3,
    };

    unsigned long const adc_model() const {return CmdFieldBitmap<1>::raw_value();}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmAdcmodel const & bm) {
    bm_os << "\n";
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.adc_model();
    bm_os << "\n   adc_model : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "no_adc_module_installed";
         break;}

    case 1 : {
         bm_os << "one_channel_adc_module_configured_for_setra_use";
         break;}

    case 2 : {
         bm_os << "generic_one_channel_adc_module";
         break;}

    case 3 : {
         bm_os << "generic_three_adc_module";
         break;}
    }
}
    bm_os << "\n";
    return bm_os;
}

class BmAlerts : public CmdFieldBitmap<1> {
friend std::ostream & operator<<(std::ostream & bm_os, BmAlerts const & bm);

public:
    explicit BmAlerts() : CmdFieldBitmap<1>{} {};
    bool const load_0_will_be_off_after_delay() const {return this -> data_.test(0);}
    bool const load_1_will_be_off_after_delay() const {return this -> data_.test(1);}
    bool const load_2_will_be_off_after_delay() const {return this -> data_.test(2);}
    bool const load_3_will_be_off_after_delay() const {return this -> data_.test(3);}
    bool const load_4_will_be_off_after_delay() const {return this -> data_.test(4);}
    bool const load_5_will_be_off_after_delay() const {return this -> data_.test(5);}
    bool const load_6_will_be_off_after_delay() const {return this -> data_.test(6);}
    bool const load_7_will_be_off_after_delay() const {return this -> data_.test(7);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmAlerts const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_0_will_be_off_after_delay() ) << "] " <<
        "load_0_will_be_off_after_delay";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_1_will_be_off_after_delay() ) << "] " <<
        "load_1_will_be_off_after_delay";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_2_will_be_off_after_delay() ) << "] " <<
        "load_2_will_be_off_after_delay";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_3_will_be_off_after_delay() ) << "] " <<
        "load_3_will_be_off_after_delay";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_4_will_be_off_after_delay() ) << "] " <<
        "load_4_will_be_off_after_delay";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_5_will_be_off_after_delay() ) << "] " <<
        "load_5_will_be_off_after_delay";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_6_will_be_off_after_delay() ) << "] " <<
        "load_6_will_be_off_after_delay";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_7_will_be_off_after_delay() ) << "] " <<
        "load_7_will_be_off_after_delay";
    bm_os << "\n";
    return bm_os;
}

class BmAuxStatusWebFlags : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmAuxStatusWebFlags const & bm);

public:
    explicit BmAuxStatusWebFlags() : CmdFieldBitmap<2>{} {};

    enum class AuxReportingInterval {
        not_reported = 0,
        one_hertz = 1,
    };


    enum class StatusPortReportingInterval {
        not_reported = 0,
        one_hertz = 1,
    };

    bool const allow_unauthenticated_baler_power_control_on_web_page() const {return this -> data_.test(2);}
    bool const allow_unauthenticated_baler_link_web_page() const {return this -> data_.test(3);}
    bool const show_q330_serial_number_on_web_page() const {return this -> data_.test(4);}
    unsigned long const aux_reporting_interval() const {return CmdFieldBitmap<2>::raw_value_from_range(0, 0x3);}
    unsigned long const status_port_reporting_interval() const {return CmdFieldBitmap<2>::raw_value_from_range(8, 0x3);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmAuxStatusWebFlags const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.allow_unauthenticated_baler_power_control_on_web_page() ) << "] " <<
        "allow_unauthenticated_baler_power_control_on_web_page";
    bm_os << "\n   [" << bm.bool_indicator( bm.allow_unauthenticated_baler_link_web_page() ) << "] " <<
        "allow_unauthenticated_baler_link_web_page";
    bm_os << "\n   [" << bm.bool_indicator( bm.show_q330_serial_number_on_web_page() ) << "] " <<
        "show_q330_serial_number_on_web_page";
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.aux_reporting_interval();
    bm_os << "\n   aux_reporting_interval : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "not_reported";
         break;}

    case 1 : {
         bm_os << "one_hertz";
         break;}
    }
}
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.status_port_reporting_interval();
    bm_os << "\n   status_port_reporting_interval : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "not_reported";
         break;}

    case 1 : {
         bm_os << "one_hertz";
         break;}
    }
}
    bm_os << "\n";
    return bm_os;
}

class BmBalerstatus : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmBalerstatus const & bm);

public:
    explicit BmBalerstatus() : CmdFieldBitmap<2>{} {};

    enum class BalerPowerStatus {
        baler_off = 0,
        baler_power_turned_on_by_a_command = 1,
        baler_power_turned_on_automatically = 2,
        baler_power_is_continuous = 3,
    };

    const unsigned long timeout_counts() const {return CmdFieldBitmap<2>::raw_value_from_range(0, 0xFFF);}
    bool const baler_is_currently_forced_off_for_the_minimum_off_time() const {return this -> data_.test(12);}
    bool const set_to_one() const {return this -> data_.test(13);}
    unsigned long const baler_power_status() const {return CmdFieldBitmap<2>::raw_value_from_range(14, 0x3);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmBalerstatus const & bm) {
    bm_os << "\n";
    bm_os << "\n   timeout_counts : " << bm.timeout_counts();
    bm_os << "\n   [" << bm.bool_indicator( bm.baler_is_currently_forced_off_for_the_minimum_off_time() ) << "] " <<
        "baler_is_currently_forced_off_for_the_minimum_off_time";
    bm_os << "\n   [" << bm.bool_indicator( bm.set_to_one() ) << "] " <<
        "set_to_one";
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.baler_power_status();
    bm_os << "\n   baler_power_status : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "baler_off";
         break;}

    case 1 : {
         bm_os << "baler_power_turned_on_by_a_command";
         break;}

    case 2 : {
         bm_os << "baler_power_turned_on_automatically";
         break;}

    case 3 : {
         bm_os << "baler_power_is_continuous";
         break;}
    }
}
    bm_os << "\n";
    return bm_os;
}

class BmBalerstatusSpecial : public CmdFieldBitmap<4> {
friend std::ostream & operator<<(std::ostream & bm_os, BmBalerstatusSpecial const & bm);

public:
    explicit BmBalerstatusSpecial() : CmdFieldBitmap<4>{} {};
    bool const baler_is_connected_on_serial_1() const {return this -> data_.test(0);}
    bool const baler_is_connected_on_serial_2() const {return this -> data_.test(1);}
    bool const baler_is_connected_on_ethernet() const {return this -> data_.test(3);}
    bool const q330_will_accept_a_connection_on_serial_1_from_a_baler_assigned_to_another_q330() const {return this -> data_.test(4);}
    bool const q330_will_accept_a_connection_on_serial_2_from_a_baler_assigned_to_another_q330() const {return this -> data_.test(5);}
    bool const q330_will_accept_a_connection_on_ethernet_from_a_baler_assigned_to_another_q330() const {return this -> data_.test(7);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmBalerstatusSpecial const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.baler_is_connected_on_serial_1() ) << "] " <<
        "baler_is_connected_on_serial_1";
    bm_os << "\n   [" << bm.bool_indicator( bm.baler_is_connected_on_serial_2() ) << "] " <<
        "baler_is_connected_on_serial_2";
    bm_os << "\n   [" << bm.bool_indicator( bm.baler_is_connected_on_ethernet() ) << "] " <<
        "baler_is_connected_on_ethernet";
    bm_os << "\n   [" << bm.bool_indicator( bm.q330_will_accept_a_connection_on_serial_1_from_a_baler_assigned_to_another_q330() ) << "] " <<
        "q330_will_accept_a_connection_on_serial_1_from_a_baler_assigned_to_another_q330";
    bm_os << "\n   [" << bm.bool_indicator( bm.q330_will_accept_a_connection_on_serial_2_from_a_baler_assigned_to_another_q330() ) << "] " <<
        "q330_will_accept_a_connection_on_serial_2_from_a_baler_assigned_to_another_q330";
    bm_os << "\n   [" << bm.bool_indicator( bm.q330_will_accept_a_connection_on_ethernet_from_a_baler_assigned_to_another_q330() ) << "] " <<
        "q330_will_accept_a_connection_on_ethernet_from_a_baler_assigned_to_another_q330";
    bm_os << "\n";
    return bm_os;
}

class BmCalFail : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmCalFail const & bm);

public:
    explicit BmCalFail() : CmdFieldBitmap<2>{} {};
    bool const channel_1_failed_calibration() const {return this -> data_.test(0);}
    bool const channel_2_failed_calibration() const {return this -> data_.test(1);}
    bool const channel_3_failed_calibration() const {return this -> data_.test(2);}
    bool const channel_4_failed_calibration() const {return this -> data_.test(3);}
    bool const channel_5_failed_calibration() const {return this -> data_.test(4);}
    bool const channel_6_failed_calibration() const {return this -> data_.test(5);}
    bool const channel_7_failed_calibration() const {return this -> data_.test(6);}
    bool const channel_8_failed_calibration() const {return this -> data_.test(7);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmCalFail const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_1_failed_calibration() ) << "] " <<
        "channel_1_failed_calibration";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_2_failed_calibration() ) << "] " <<
        "channel_2_failed_calibration";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_3_failed_calibration() ) << "] " <<
        "channel_3_failed_calibration";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_4_failed_calibration() ) << "] " <<
        "channel_4_failed_calibration";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_5_failed_calibration() ) << "] " <<
        "channel_5_failed_calibration";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_6_failed_calibration() ) << "] " <<
        "channel_6_failed_calibration";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_7_failed_calibration() ) << "] " <<
        "channel_7_failed_calibration";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_8_failed_calibration() ) << "] " <<
        "channel_8_failed_calibration";
    bm_os << "\n";
    return bm_os;
}

class BmCalMonitorChannel : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmCalMonitorChannel const & bm);

public:
    explicit BmCalMonitorChannel() : CmdFieldBitmap<2>{} {};
    bool const channel_1() const {return this -> data_.test(0);}
    bool const channel_2() const {return this -> data_.test(1);}
    bool const channel_3() const {return this -> data_.test(2);}
    bool const channel_4() const {return this -> data_.test(3);}
    bool const channel_5() const {return this -> data_.test(4);}
    bool const channel_6() const {return this -> data_.test(5);}
    void channel_1(const bool b) {this -> data_.set(0, b);}
    void channel_2(const bool b) {this -> data_.set(1, b);}
    void channel_3(const bool b) {this -> data_.set(2, b);}
    void channel_4(const bool b) {this -> data_.set(3, b);}
    void channel_5(const bool b) {this -> data_.set(4, b);}
    void channel_6(const bool b) {this -> data_.set(5, b);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmCalMonitorChannel const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_1() ) << "] " <<
        "channel_1";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_2() ) << "] " <<
        "channel_2";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_3() ) << "] " <<
        "channel_3";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_4() ) << "] " <<
        "channel_4";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_5() ) << "] " <<
        "channel_5";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_6() ) << "] " <<
        "channel_6";
    bm_os << "\n";
    return bm_os;
}

class BmCalSensorControlBitmap : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmCalSensorControlBitmap const & bm);

public:
    explicit BmCalSensorControlBitmap() : CmdFieldBitmap<2>{} {};
    bool const genen_1_a() const {return this -> data_.test(0);}
    bool const genen_2_a() const {return this -> data_.test(1);}
    bool const genen_3_a() const {return this -> data_.test(2);}
    bool const calen_a() const {return this -> data_.test(3);}
    bool const genen_1_b() const {return this -> data_.test(4);}
    bool const genen_2_b() const {return this -> data_.test(5);}
    bool const genen_3_b() const {return this -> data_.test(6);}
    bool const calen_b() const {return this -> data_.test(7);}
    void genen_1_a(const bool b) {this -> data_.set(0, b);}
    void genen_2_a(const bool b) {this -> data_.set(1, b);}
    void genen_3_a(const bool b) {this -> data_.set(2, b);}
    void calen_a(const bool b) {this -> data_.set(3, b);}
    void genen_1_b(const bool b) {this -> data_.set(4, b);}
    void genen_2_b(const bool b) {this -> data_.set(5, b);}
    void genen_3_b(const bool b) {this -> data_.set(6, b);}
    void calen_b(const bool b) {this -> data_.set(7, b);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmCalSensorControlBitmap const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.genen_1_a() ) << "] " <<
        "genen_1_a";
    bm_os << "\n   [" << bm.bool_indicator( bm.genen_2_a() ) << "] " <<
        "genen_2_a";
    bm_os << "\n   [" << bm.bool_indicator( bm.genen_3_a() ) << "] " <<
        "genen_3_a";
    bm_os << "\n   [" << bm.bool_indicator( bm.calen_a() ) << "] " <<
        "calen_a";
    bm_os << "\n   [" << bm.bool_indicator( bm.genen_1_b() ) << "] " <<
        "genen_1_b";
    bm_os << "\n   [" << bm.bool_indicator( bm.genen_2_b() ) << "] " <<
        "genen_2_b";
    bm_os << "\n   [" << bm.bool_indicator( bm.genen_3_b() ) << "] " <<
        "genen_3_b";
    bm_os << "\n   [" << bm.bool_indicator( bm.calen_b() ) << "] " <<
        "calen_b";
    bm_os << "\n";
    return bm_os;
}

class BmCalWaveform : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmCalWaveform const & bm);

public:
    explicit BmCalWaveform() : CmdFieldBitmap<2>{} {};

    enum class Waveform {
        sine = 0,
        red_noise = 1,
        white_noise = 2,
        step = 3,
        random = 4,
    };

    bool const negative_step() const {return this -> data_.test(6);}
    bool const automatic_calibration() const {return this -> data_.test(7);}
    unsigned long const waveform() const {return CmdFieldBitmap<2>::raw_value_from_range(0, 0x7);}
    void negative_step(const bool b) {this -> data_.set(6, b);}
    void automatic_calibration(const bool b) {this -> data_.set(7, b);}
    void waveform(Waveform const c) {CmdFieldBitmap<2>::set_raw_value_in_range(0, 0x7, static_cast<unsigned long>(c) );}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmCalWaveform const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.negative_step() ) << "] " <<
        "negative_step";
    bm_os << "\n   [" << bm.bool_indicator( bm.automatic_calibration() ) << "] " <<
        "automatic_calibration";
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.waveform();
    bm_os << "\n   waveform : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "sine";
         break;}

    case 1 : {
         bm_os << "red_noise";
         break;}

    case 2 : {
         bm_os << "white_noise";
         break;}

    case 3 : {
         bm_os << "step";
         break;}

    case 4 : {
         bm_os << "random";
         break;}
    }
}
    bm_os << "\n";
    return bm_os;
}

class BmCalibrationBitmap : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmCalibrationBitmap const & bm);

public:
    explicit BmCalibrationBitmap() : CmdFieldBitmap<2>{} {};

    enum class Input {
        a = 3,
        b = 56,
    };

    unsigned long const input() const {return CmdFieldBitmap<2>::raw_value();}
    void input(Input const c) {this -> data_ = std::bitset<16>( static_cast<unsigned long>(c) );}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmCalibrationBitmap const & bm) {
    bm_os << "\n";
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.input();
    bm_os << "\n   input : " << c << " : ";
    switch(c) {

    case 3 : {
         bm_os << "a";
         break;}

    case 56 : {
         bm_os << "b";
         break;}
    }
}
    bm_os << "\n";
    return bm_os;
}

class BmCerr : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmCerr const & bm);

public:
    explicit BmCerr() : CmdFieldBitmap<2>{} {};

    enum class ErrorCode {
        no_permission_invalid_password = 0,
        too_many_configuration_or_special_functions = 1,
        you_are_not_registered = 2,
        invalid_registration_response = 3,
        parameter_error = 4,
        tried_to_read_an_eeprom_structure_that_is_not_valid = 5,
        configuration_only = 6,
        special_functions_port_only = 7,
        memory_operation_in_progress = 8,
        calibration_in_progress = 9,
        data_not_yet_available_for_quickview = 10,
        console_virtual_interface_only = 11,
        flash_write_or_erase_error = 12,
    };

    unsigned long const error_code() const {return CmdFieldBitmap<2>::raw_value();}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmCerr const & bm) {
    bm_os << "\n";
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.error_code();
    bm_os << "\n   error_code : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "no_permission_invalid_password";
         break;}

    case 1 : {
         bm_os << "too_many_configuration_or_special_functions";
         break;}

    case 2 : {
         bm_os << "you_are_not_registered";
         break;}

    case 3 : {
         bm_os << "invalid_registration_response";
         break;}

    case 4 : {
         bm_os << "parameter_error";
         break;}

    case 5 : {
         bm_os << "tried_to_read_an_eeprom_structure_that_is_not_valid";
         break;}

    case 6 : {
         bm_os << "configuration_only";
         break;}

    case 7 : {
         bm_os << "special_functions_port_only";
         break;}

    case 8 : {
         bm_os << "memory_operation_in_progress";
         break;}

    case 9 : {
         bm_os << "calibration_in_progress";
         break;}

    case 10 : {
         bm_os << "data_not_yet_available_for_quickview";
         break;}

    case 11 : {
         bm_os << "console_virtual_interface_only";
         break;}

    case 12 : {
         bm_os << "flash_write_or_erase_error";
         break;}
    }
}
    bm_os << "\n";
    return bm_os;
}

class BmChannelMap : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmChannelMap const & bm);

public:
    explicit BmChannelMap() : CmdFieldBitmap<2>{} {};
    bool const channel_1() const {return this -> data_.test(0);}
    bool const channel_2() const {return this -> data_.test(1);}
    bool const channel_3() const {return this -> data_.test(2);}
    bool const channel_4() const {return this -> data_.test(3);}
    bool const channel_5() const {return this -> data_.test(4);}
    bool const channel_6() const {return this -> data_.test(5);}
    void channel_1(const bool b) {this -> data_.set(0, b);}
    void channel_2(const bool b) {this -> data_.set(1, b);}
    void channel_3(const bool b) {this -> data_.set(2, b);}
    void channel_4(const bool b) {this -> data_.set(3, b);}
    void channel_5(const bool b) {this -> data_.set(4, b);}
    void channel_6(const bool b) {this -> data_.set(5, b);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmChannelMap const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_1() ) << "] " <<
        "channel_1";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_2() ) << "] " <<
        "channel_2";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_3() ) << "] " <<
        "channel_3";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_4() ) << "] " <<
        "channel_4";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_5() ) << "] " <<
        "channel_5";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_6() ) << "] " <<
        "channel_6";
    bm_os << "\n";
    return bm_os;
}

class BmChargingPhase : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmChargingPhase const & bm);

public:
    explicit BmChargingPhase() : CmdFieldBitmap<2>{} {};

    enum class ChargingPhase {
        not_charging = 0,
        bulk = 1,
        absorption = 2,
        float_phase = 3,
        equalization = 4,
    };

    unsigned long const charging_phase() const {return CmdFieldBitmap<2>::raw_value();}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmChargingPhase const & bm) {
    bm_os << "\n";
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.charging_phase();
    bm_os << "\n   charging_phase : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "not_charging";
         break;}

    case 1 : {
         bm_os << "bulk";
         break;}

    case 2 : {
         bm_os << "absorption";
         break;}

    case 3 : {
         bm_os << "float_phase";
         break;}

    case 4 : {
         bm_os << "equalization";
         break;}
    }
}
    bm_os << "\n";
    return bm_os;
}

class BmCtrlFlags : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmCtrlFlags const & bm);

public:
    explicit BmCtrlFlags() : CmdFieldBitmap<2>{} {};
    bool const save_current_programming_to_eeprom() const {return this -> data_.test(0);}
    bool const reboot() const {return this -> data_.test(1);}
    bool const re_sync() const {return this -> data_.test(2);}
    bool const turn_gps_on() const {return this -> data_.test(3);}
    bool const turn_gps_off() const {return this -> data_.test(4);}
    bool const cold_start_gps() const {return this -> data_.test(5);}
    bool const reboot_envproc_on_serial_1() const {return this -> data_.test(6);}
    bool const reboot_envproc_on_serial_2() const {return this -> data_.test(7);}
    void save_current_programming_to_eeprom(const bool b) {this -> data_.set(0, b);}
    void reboot(const bool b) {this -> data_.set(1, b);}
    void re_sync(const bool b) {this -> data_.set(2, b);}
    void turn_gps_on(const bool b) {this -> data_.set(3, b);}
    void turn_gps_off(const bool b) {this -> data_.set(4, b);}
    void cold_start_gps(const bool b) {this -> data_.set(5, b);}
    void reboot_envproc_on_serial_1(const bool b) {this -> data_.set(6, b);}
    void reboot_envproc_on_serial_2(const bool b) {this -> data_.set(7, b);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmCtrlFlags const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.save_current_programming_to_eeprom() ) << "] " <<
        "save_current_programming_to_eeprom";
    bm_os << "\n   [" << bm.bool_indicator( bm.reboot() ) << "] " <<
        "reboot";
    bm_os << "\n   [" << bm.bool_indicator( bm.re_sync() ) << "] " <<
        "re_sync";
    bm_os << "\n   [" << bm.bool_indicator( bm.turn_gps_on() ) << "] " <<
        "turn_gps_on";
    bm_os << "\n   [" << bm.bool_indicator( bm.turn_gps_off() ) << "] " <<
        "turn_gps_off";
    bm_os << "\n   [" << bm.bool_indicator( bm.cold_start_gps() ) << "] " <<
        "cold_start_gps";
    bm_os << "\n   [" << bm.bool_indicator( bm.reboot_envproc_on_serial_1() ) << "] " <<
        "reboot_envproc_on_serial_1";
    bm_os << "\n   [" << bm.bool_indicator( bm.reboot_envproc_on_serial_2() ) << "] " <<
        "reboot_envproc_on_serial_2";
    bm_os << "\n";
    return bm_os;
}

class BmDevOpt : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmDevOpt const & bm);

public:
    explicit BmDevOpt() : CmdFieldBitmap<2>{} {};
    bool const polling_for_data_status_enabled() const {return this -> data_.test(0);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmDevOpt const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.polling_for_data_status_enabled() ) << "] " <<
        "polling_for_data_status_enabled";
    bm_os << "\n";
    return bm_os;
}

class BmDevUnitid : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmDevUnitid const & bm);

public:
    explicit BmDevUnitid() : CmdFieldBitmap<2>{} {};

    enum class UnitId {
        sp1320_power_supply = 13,
        power_supply_1 = 15,
        power_supply_2 = 17,
        power_supply_3 = 19,
        black_and_white_camera = 20,
        qcal_calibrator = 33,
        whoi_controller = 99,
    };

    unsigned long const unit_id() const {return CmdFieldBitmap<2>::raw_value();}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmDevUnitid const & bm) {
    bm_os << "\n";
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.unit_id();
    bm_os << "\n   unit_id : " << c << " : ";
    switch(c) {

    case 13 : {
         bm_os << "sp1320_power_supply";
         break;}

    case 15 : {
         bm_os << "power_supply_1";
         break;}

    case 17 : {
         bm_os << "power_supply_2";
         break;}

    case 19 : {
         bm_os << "power_supply_3";
         break;}

    case 20 : {
         bm_os << "black_and_white_camera";
         break;}

    case 33 : {
         bm_os << "qcal_calibrator";
         break;}

    case 99 : {
         bm_os << "whoi_controller";
         break;}
    }
}
    bm_os << "\n";
    return bm_os;
}

class BmEthernetLinkstatus : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmEthernetLinkstatus const & bm);

public:
    explicit BmEthernetLinkstatus() : CmdFieldBitmap<2>{} {};
    bool const polarity_ok() const {return this -> data_.test(4);}
    bool const link_ok() const {return this -> data_.test(15);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmEthernetLinkstatus const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.polarity_ok() ) << "] " <<
        "polarity_ok";
    bm_os << "\n   [" << bm.bool_indicator( bm.link_ok() ) << "] " <<
        "link_ok";
    bm_os << "\n";
    return bm_os;
}

class BmFgDataport : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmFgDataport const & bm);

public:
    explicit BmFgDataport() : CmdFieldBitmap<2>{} {};
    bool const baler_should_disconnect_and_prepare_to_reconnect_to_a_data_vacuum() const {return this -> data_.test(0);}
    bool const baler_should_stay_powered_on() const {return this -> data_.test(1);}
    bool const baler_should_shutdown_immediately() const {return this -> data_.test(2);}
    bool const packet_memory_reduced_due_to_bad_packet_memory_ram() const {return this -> data_.test(15);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmFgDataport const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.baler_should_disconnect_and_prepare_to_reconnect_to_a_data_vacuum() ) << "] " <<
        "baler_should_disconnect_and_prepare_to_reconnect_to_a_data_vacuum";
    bm_os << "\n   [" << bm.bool_indicator( bm.baler_should_stay_powered_on() ) << "] " <<
        "baler_should_stay_powered_on";
    bm_os << "\n   [" << bm.bool_indicator( bm.baler_should_shutdown_immediately() ) << "] " <<
        "baler_should_shutdown_immediately";
    bm_os << "\n   [" << bm.bool_indicator( bm.packet_memory_reduced_due_to_bad_packet_memory_ram() ) << "] " <<
        "packet_memory_reduced_due_to_bad_packet_memory_ram";
    bm_os << "\n";
    return bm_os;
}

class BmFgEnvironmental : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmFgEnvironmental const & bm);

public:
    explicit BmFgEnvironmental() : CmdFieldBitmap<2>{} {};
    bool const flash_manufacturing_constants_are_not_valid() const {return this -> data_.test(0);}
    bool const aux_io_line_1_is_active() const {return this -> data_.test(1);}
    bool const aux_io_line_2_is_active() const {return this -> data_.test(2);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmFgEnvironmental const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.flash_manufacturing_constants_are_not_valid() ) << "] " <<
        "flash_manufacturing_constants_are_not_valid";
    bm_os << "\n   [" << bm.bool_indicator( bm.aux_io_line_1_is_active() ) << "] " <<
        "aux_io_line_1_is_active";
    bm_os << "\n   [" << bm.bool_indicator( bm.aux_io_line_2_is_active() ) << "] " <<
        "aux_io_line_2_is_active";
    bm_os << "\n";
    return bm_os;
}

class BmFgFix : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmFgFix const & bm);

public:
    explicit BmFgFix() : CmdFieldBitmap<2>{} {};
    bool const ethernet_installed() const {return this -> data_.test(0);}
    bool const can_statreq_dynamic_ip() const {return this -> data_.test(1);}
    bool const can_statreq_auxiliary_board() const {return this -> data_.test(2);}
    bool const can_expanded_c1_web_cmds() const {return this -> data_.test(3);}
    bool const can_statreq_serial_sensor() const {return this -> data_.test(4);}
    bool const can_report_255maplus_supply_current() const {return this -> data_.test(5);}
    bool const at_least_one_environmental_proc_configured() const {return this -> data_.test(6);}
    bool const is_Q330S() const {return this -> data_.test(7);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmFgFix const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.ethernet_installed() ) << "] " <<
        "ethernet_installed";
    bm_os << "\n   [" << bm.bool_indicator( bm.can_statreq_dynamic_ip() ) << "] " <<
        "can_statreq_dynamic_ip";
    bm_os << "\n   [" << bm.bool_indicator( bm.can_statreq_auxiliary_board() ) << "] " <<
        "can_statreq_auxiliary_board";
    bm_os << "\n   [" << bm.bool_indicator( bm.can_expanded_c1_web_cmds() ) << "] " <<
        "can_expanded_c1_web_cmds";
    bm_os << "\n   [" << bm.bool_indicator( bm.can_statreq_serial_sensor() ) << "] " <<
        "can_statreq_serial_sensor";
    bm_os << "\n   [" << bm.bool_indicator( bm.can_report_255maplus_supply_current() ) << "] " <<
        "can_report_255maplus_supply_current";
    bm_os << "\n   [" << bm.bool_indicator( bm.at_least_one_environmental_proc_configured() ) << "] " <<
        "at_least_one_environmental_proc_configured";
    bm_os << "\n   [" << bm.bool_indicator( bm.is_Q330S() ) << "] " <<
        "is_Q330S";
    bm_os << "\n";
    return bm_os;
}

class BmFgSphy : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmFgSphy const & bm);

public:
    explicit BmFgSphy() : CmdFieldBitmap<2>{} {};
    bool const fill_mode_enabled() const {return this -> data_.test(0);}
    bool const flush_packet_buffer_time_based() const {return this -> data_.test(1);}
    bool const freeze_data_port_output() const {return this -> data_.test(2);}
    bool const freeze_packet_buff_input() const {return this -> data_.test(3);}
    bool const keep_oldest_data_packet_buffer() const {return this -> data_.test(4);}
    bool const dp_piggyback_statreq_with_dt_dack() const {return this -> data_.test(8);}
    bool const comm_fault_led_if_last_flush_buff_5plus() const {return this -> data_.test(9);}
    bool const allow_hotswap_on_this_dataport() const {return this -> data_.test(10);}
    bool const flush_sliding_window_buff_based_on_time() const {return this -> data_.test(11);}
    bool const send_datapackets_encoded_base_96() const {return this -> data_.test(14);}
    bool const save_changes_in_eeprom() const {return this -> data_.test(15);}
    void fill_mode_enabled(const bool b) {this -> data_.set(0, b);}
    void flush_packet_buffer_time_based(const bool b) {this -> data_.set(1, b);}
    void freeze_data_port_output(const bool b) {this -> data_.set(2, b);}
    void freeze_packet_buff_input(const bool b) {this -> data_.set(3, b);}
    void keep_oldest_data_packet_buffer(const bool b) {this -> data_.set(4, b);}
    void dp_piggyback_statreq_with_dt_dack(const bool b) {this -> data_.set(8, b);}
    void comm_fault_led_if_last_flush_buff_5plus(const bool b) {this -> data_.set(9, b);}
    void allow_hotswap_on_this_dataport(const bool b) {this -> data_.set(10, b);}
    void flush_sliding_window_buff_based_on_time(const bool b) {this -> data_.set(11, b);}
    void send_datapackets_encoded_base_96(const bool b) {this -> data_.set(14, b);}
    void save_changes_in_eeprom(const bool b) {this -> data_.set(15, b);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmFgSphy const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.fill_mode_enabled() ) << "] " <<
        "fill_mode_enabled";
    bm_os << "\n   [" << bm.bool_indicator( bm.flush_packet_buffer_time_based() ) << "] " <<
        "flush_packet_buffer_time_based";
    bm_os << "\n   [" << bm.bool_indicator( bm.freeze_data_port_output() ) << "] " <<
        "freeze_data_port_output";
    bm_os << "\n   [" << bm.bool_indicator( bm.freeze_packet_buff_input() ) << "] " <<
        "freeze_packet_buff_input";
    bm_os << "\n   [" << bm.bool_indicator( bm.keep_oldest_data_packet_buffer() ) << "] " <<
        "keep_oldest_data_packet_buffer";
    bm_os << "\n   [" << bm.bool_indicator( bm.dp_piggyback_statreq_with_dt_dack() ) << "] " <<
        "dp_piggyback_statreq_with_dt_dack";
    bm_os << "\n   [" << bm.bool_indicator( bm.comm_fault_led_if_last_flush_buff_5plus() ) << "] " <<
        "comm_fault_led_if_last_flush_buff_5plus";
    bm_os << "\n   [" << bm.bool_indicator( bm.allow_hotswap_on_this_dataport() ) << "] " <<
        "allow_hotswap_on_this_dataport";
    bm_os << "\n   [" << bm.bool_indicator( bm.flush_sliding_window_buff_based_on_time() ) << "] " <<
        "flush_sliding_window_buff_based_on_time";
    bm_os << "\n   [" << bm.bool_indicator( bm.send_datapackets_encoded_base_96() ) << "] " <<
        "send_datapackets_encoded_base_96";
    bm_os << "\n   [" << bm.bool_indicator( bm.save_changes_in_eeprom() ) << "] " <<
        "save_changes_in_eeprom";
    bm_os << "\n";
    return bm_os;
}

class BmFgThread : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmFgThread const & bm);

public:
    explicit BmFgThread() : CmdFieldBitmap<2>{} {};
    const unsigned long global_event_value() const {return CmdFieldBitmap<2>::raw_value_from_range(0, 0x1FFF);}
    bool const global_event() const {return this -> data_.test(13);}
    bool const thread_is_waiting_for_an_event() const {return this -> data_.test(14);}
    bool const thread_is_blocked() const {return this -> data_.test(15);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmFgThread const & bm) {
    bm_os << "\n";
    bm_os << "\n   global_event_value : " << bm.global_event_value();
    bm_os << "\n   [" << bm.bool_indicator( bm.global_event() ) << "] " <<
        "global_event";
    bm_os << "\n   [" << bm.bool_indicator( bm.thread_is_waiting_for_an_event() ) << "] " <<
        "thread_is_waiting_for_an_event";
    bm_os << "\n   [" << bm.bool_indicator( bm.thread_is_blocked() ) << "] " <<
        "thread_is_blocked";
    bm_os << "\n";
    return bm_os;
}

class BmFirmwareversion : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmFirmwareversion const & bm);

public:
    explicit BmFirmwareversion() : CmdFieldBitmap<2>{} {};
    const unsigned long firmware_version() const {return CmdFieldBitmap<2>::raw_value_from_range(8, 0xFF);}
    const unsigned long firmware_revision() const {return CmdFieldBitmap<2>::raw_value_from_range(0, 0xFF);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmFirmwareversion const & bm) {
    bm_os << "\n";
    bm_os << "\n   firmware_version : " << bm.firmware_version();
    bm_os << "\n   firmware_revision : " << bm.firmware_revision();
    bm_os << "\n";
    return bm_os;
}

class BmGainPreAmp : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmGainPreAmp const & bm);

public:
    explicit BmGainPreAmp() : CmdFieldBitmap<2>{} {};

    enum class GainPreAmpChannel1 {
        disabled = 0,
        pre_amp_off = 1,
        pre_amp_on = 2,
    };


    enum class GainPreAmpChannel2 {
        disabled = 0,
        pre_amp_off = 1,
        pre_amp_on = 2,
    };


    enum class GainPreAmpChannel3 {
        disabled = 0,
        pre_amp_off = 1,
        pre_amp_on = 2,
    };


    enum class GainPreAmpChannel4 {
        disabled = 0,
        pre_amp_off = 1,
        pre_amp_on = 2,
    };


    enum class GainPreAmpChannel5 {
        disabled = 0,
        pre_amp_off = 1,
        pre_amp_on = 2,
    };


    enum class GainPreAmpChannel6 {
        disabled = 0,
        pre_amp_off = 1,
        pre_amp_on = 2,
    };

    unsigned long const gain_pre_amp_channel_1() const {return CmdFieldBitmap<2>::raw_value_from_range(0, 0x3);}
    unsigned long const gain_pre_amp_channel_2() const {return CmdFieldBitmap<2>::raw_value_from_range(2, 0x3);}
    unsigned long const gain_pre_amp_channel_3() const {return CmdFieldBitmap<2>::raw_value_from_range(4, 0x3);}
    unsigned long const gain_pre_amp_channel_4() const {return CmdFieldBitmap<2>::raw_value_from_range(6, 0x3);}
    unsigned long const gain_pre_amp_channel_5() const {return CmdFieldBitmap<2>::raw_value_from_range(8, 0x3);}
    unsigned long const gain_pre_amp_channel_6() const {return CmdFieldBitmap<2>::raw_value_from_range(10, 0x3);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmGainPreAmp const & bm) {
    bm_os << "\n";
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.gain_pre_amp_channel_1();
    bm_os << "\n   gain_pre_amp_channel_1 : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "disabled";
         break;}

    case 1 : {
         bm_os << "pre_amp_off";
         break;}

    case 2 : {
         bm_os << "pre_amp_on";
         break;}
    }
}
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.gain_pre_amp_channel_2();
    bm_os << "\n   gain_pre_amp_channel_2 : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "disabled";
         break;}

    case 1 : {
         bm_os << "pre_amp_off";
         break;}

    case 2 : {
         bm_os << "pre_amp_on";
         break;}
    }
}
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.gain_pre_amp_channel_3();
    bm_os << "\n   gain_pre_amp_channel_3 : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "disabled";
         break;}

    case 1 : {
         bm_os << "pre_amp_off";
         break;}

    case 2 : {
         bm_os << "pre_amp_on";
         break;}
    }
}
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.gain_pre_amp_channel_4();
    bm_os << "\n   gain_pre_amp_channel_4 : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "disabled";
         break;}

    case 1 : {
         bm_os << "pre_amp_off";
         break;}

    case 2 : {
         bm_os << "pre_amp_on";
         break;}
    }
}
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.gain_pre_amp_channel_5();
    bm_os << "\n   gain_pre_amp_channel_5 : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "disabled";
         break;}

    case 1 : {
         bm_os << "pre_amp_off";
         break;}

    case 2 : {
         bm_os << "pre_amp_on";
         break;}
    }
}
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.gain_pre_amp_channel_6();
    bm_os << "\n   gain_pre_amp_channel_6 : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "disabled";
         break;}

    case 1 : {
         bm_os << "pre_amp_off";
         break;}

    case 2 : {
         bm_os << "pre_amp_on";
         break;}
    }
}
    bm_os << "\n";
    return bm_os;
}

class BmInitialVco : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmInitialVco const & bm);

public:
    explicit BmInitialVco() : CmdFieldBitmap<2>{} {};
    bool const automatic_vco_setting_by_pll() const {return this -> data_.test(15);}
    const unsigned long initial_vco() const {return CmdFieldBitmap<2>::raw_value_from_range(0, 0xFFF);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmInitialVco const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.automatic_vco_setting_by_pll() ) << "] " <<
        "automatic_vco_setting_by_pll";
    bm_os << "\n   initial_vco : " << bm.initial_vco();
    bm_os << "\n";
    return bm_os;
}

class BmInputBitmap : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmInputBitmap const & bm);

public:
    explicit BmInputBitmap() : CmdFieldBitmap<2>{} {};

    enum class InputAType {
        one_pps_input = 0,
        reference_input = 1,
        calibrator_output = 2,
        grounded_input = 3,
    };


    enum class InputBType {
        one_pps_input = 0,
        reference_input = 1,
        calibrator_output = 2,
        grounded_input = 3,
    };

    bool const channel_1_uses_mux_special_input() const {return this -> data_.test(0);}
    bool const channel_2_uses_mux_special_input() const {return this -> data_.test(1);}
    bool const channel_3_uses_mux_special_input() const {return this -> data_.test(2);}
    bool const channel_4_uses_mux_special_input() const {return this -> data_.test(3);}
    bool const channel_5_uses_mux_special_input() const {return this -> data_.test(4);}
    bool const channel_6_uses_mux_special_input() const {return this -> data_.test(5);}
    unsigned long const input_a_type() const {return CmdFieldBitmap<2>::raw_value_from_range(8, 0x3);}
    unsigned long const input_b_type() const {return CmdFieldBitmap<2>::raw_value_from_range(10, 0x3);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmInputBitmap const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_1_uses_mux_special_input() ) << "] " <<
        "channel_1_uses_mux_special_input";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_2_uses_mux_special_input() ) << "] " <<
        "channel_2_uses_mux_special_input";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_3_uses_mux_special_input() ) << "] " <<
        "channel_3_uses_mux_special_input";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_4_uses_mux_special_input() ) << "] " <<
        "channel_4_uses_mux_special_input";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_5_uses_mux_special_input() ) << "] " <<
        "channel_5_uses_mux_special_input";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_6_uses_mux_special_input() ) << "] " <<
        "channel_6_uses_mux_special_input";
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.input_a_type();
    bm_os << "\n   input_a_type : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "one_pps_input";
         break;}

    case 1 : {
         bm_os << "reference_input";
         break;}

    case 2 : {
         bm_os << "calibrator_output";
         break;}

    case 3 : {
         bm_os << "grounded_input";
         break;}
    }
}
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.input_b_type();
    bm_os << "\n   input_b_type : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "one_pps_input";
         break;}

    case 1 : {
         bm_os << "reference_input";
         break;}

    case 2 : {
         bm_os << "calibrator_output";
         break;}

    case 3 : {
         bm_os << "grounded_input";
         break;}
    }
}
    bm_os << "\n";
    return bm_os;
}

class BmLinearPhaseFilters : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmLinearPhaseFilters const & bm);

public:
    explicit BmLinearPhaseFilters() : CmdFieldBitmap<2>{} {};

    enum class LinearPhaseFiltersInputA {
        for_all_frequencies = 0,
        below_100Hz = 1,
        below_40Hz = 2,
        below_20Hz = 3,
    };


    enum class LinearPhaseFiltersInputB {
        for_all_frequencies = 0,
        below_100Hz = 1,
        below_40Hz = 2,
        below_20Hz = 3,
    };

    unsigned long const linear_phase_filters_input_a() const {return CmdFieldBitmap<2>::raw_value_from_range(0, 0x3);}
    unsigned long const linear_phase_filters_input_b() const {return CmdFieldBitmap<2>::raw_value_from_range(2, 0x3);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmLinearPhaseFilters const & bm) {
    bm_os << "\n";
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.linear_phase_filters_input_a();
    bm_os << "\n   linear_phase_filters_input_a : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "for_all_frequencies";
         break;}

    case 1 : {
         bm_os << "below_100Hz";
         break;}

    case 2 : {
         bm_os << "below_40Hz";
         break;}

    case 3 : {
         bm_os << "below_20Hz";
         break;}
    }
}
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.linear_phase_filters_input_b();
    bm_os << "\n   linear_phase_filters_input_b : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "for_all_frequencies";
         break;}

    case 1 : {
         bm_os << "below_100Hz";
         break;}

    case 2 : {
         bm_os << "below_40Hz";
         break;}

    case 3 : {
         bm_os << "below_20Hz";
         break;}
    }
}
    bm_os << "\n";
    return bm_os;
}

class BmLoadsOff : public CmdFieldBitmap<1> {
friend std::ostream & operator<<(std::ostream & bm_os, BmLoadsOff const & bm);

public:
    explicit BmLoadsOff() : CmdFieldBitmap<1>{} {};
    bool const load_0_is_currently_off() const {return this -> data_.test(0);}
    bool const load_1_is_currently_off() const {return this -> data_.test(1);}
    bool const load_2_is_currently_off() const {return this -> data_.test(2);}
    bool const load_3_is_currently_off() const {return this -> data_.test(3);}
    bool const load_4_is_currently_off() const {return this -> data_.test(4);}
    bool const load_5_is_currently_off() const {return this -> data_.test(5);}
    bool const load_6_is_currently_off() const {return this -> data_.test(6);}
    bool const load_7_is_currently_off() const {return this -> data_.test(7);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmLoadsOff const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_0_is_currently_off() ) << "] " <<
        "load_0_is_currently_off";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_1_is_currently_off() ) << "] " <<
        "load_1_is_currently_off";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_2_is_currently_off() ) << "] " <<
        "load_2_is_currently_off";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_3_is_currently_off() ) << "] " <<
        "load_3_is_currently_off";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_4_is_currently_off() ) << "] " <<
        "load_4_is_currently_off";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_5_is_currently_off() ) << "] " <<
        "load_5_is_currently_off";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_6_is_currently_off() ) << "] " <<
        "load_6_is_currently_off";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_7_is_currently_off() ) << "] " <<
        "load_7_is_currently_off";
    bm_os << "\n";
    return bm_os;
}

class BmMiscInputs : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmMiscInputs const & bm);

public:
    explicit BmMiscInputs() : CmdFieldBitmap<2>{} {};
    bool const ac_ok() const {return this -> data_.test(0);}
    bool const input_spare_1() const {return this -> data_.test(1);}
    bool const input_spare_2() const {return this -> data_.test(2);}
    bool const analog_fault() const {return this -> data_.test(3);}
    bool const main_power() const {return this -> data_.test(4);}
    bool const analog_power() const {return this -> data_.test(6);}
    bool const trigger() const {return this -> data_.test(7);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmMiscInputs const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.ac_ok() ) << "] " <<
        "ac_ok";
    bm_os << "\n   [" << bm.bool_indicator( bm.input_spare_1() ) << "] " <<
        "input_spare_1";
    bm_os << "\n   [" << bm.bool_indicator( bm.input_spare_2() ) << "] " <<
        "input_spare_2";
    bm_os << "\n   [" << bm.bool_indicator( bm.analog_fault() ) << "] " <<
        "analog_fault";
    bm_os << "\n   [" << bm.bool_indicator( bm.main_power() ) << "] " <<
        "main_power";
    bm_os << "\n   [" << bm.bool_indicator( bm.analog_power() ) << "] " <<
        "analog_power";
    bm_os << "\n   [" << bm.bool_indicator( bm.trigger() ) << "] " <<
        "trigger";
    bm_os << "\n";
    return bm_os;
}

class BmPllState : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmPllState const & bm);

public:
    explicit BmPllState() : CmdFieldBitmap<2>{} {};

    enum class PllStatus {
        pll_not_enabled = 0,
        pll_hold = 1,
        pll_tracking = 2,
        pll_locked = 3,
    };

    unsigned long const pll_status() const {return CmdFieldBitmap<2>::raw_value_from_range(6, 0x3);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmPllState const & bm) {
    bm_os << "\n";
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.pll_status();
    bm_os << "\n   pll_status : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "pll_not_enabled";
         break;}

    case 1 : {
         bm_os << "pll_hold";
         break;}

    case 2 : {
         bm_os << "pll_tracking";
         break;}

    case 3 : {
         bm_os << "pll_locked";
         break;}
    }
}
    bm_os << "\n";
    return bm_os;
}

class BmProcessorid : public CmdFieldBitmap<4> {
friend std::ostream & operator<<(std::ostream & bm_os, BmProcessorid const & bm);

public:
    explicit BmProcessorid() : CmdFieldBitmap<4>{} {};
    const unsigned long architecture_revision() const {return CmdFieldBitmap<4>::raw_value_from_range(10, 0x7);}
    const unsigned long architecture_type() const {return CmdFieldBitmap<4>::raw_value_from_range(13, 0x7);}
    const unsigned long processor_revision() const {return CmdFieldBitmap<4>::raw_value_from_range(16, 0xF);}
    const unsigned long processor_type() const {return CmdFieldBitmap<4>::raw_value_from_range(24, 0xFF);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmProcessorid const & bm) {
    bm_os << "\n";
    bm_os << "\n   architecture_revision : " << bm.architecture_revision();
    bm_os << "\n   architecture_type : " << bm.architecture_type();
    bm_os << "\n   processor_revision : " << bm.processor_revision();
    bm_os << "\n   processor_type : " << bm.processor_type();
    bm_os << "\n";
    return bm_os;
}

class BmRqstat : public CmdFieldBitmap<4> {
friend std::ostream & operator<<(std::ostream & bm_os, BmRqstat const & bm);

public:
    explicit BmRqstat() : CmdFieldBitmap<4>{} {};
    bool const global_status() const {return this -> data_.test(0);}
    bool const gps_status() const {return this -> data_.test(1);}
    bool const power_supply_status() const {return this -> data_.test(2);}
    bool const boom_positions() const {return this -> data_.test(3);}
    bool const thread_status() const {return this -> data_.test(4);}
    bool const pll_status() const {return this -> data_.test(5);}
    bool const gps_satellites() const {return this -> data_.test(6);}
    bool const arp_status() const {return this -> data_.test(7);}
    bool const data_port_1_status() const {return this -> data_.test(8);}
    bool const data_port_2_status() const {return this -> data_.test(9);}
    bool const data_port_3_status() const {return this -> data_.test(10);}
    bool const data_port_4_status() const {return this -> data_.test(11);}
    bool const serial_interface_1_status() const {return this -> data_.test(12);}
    bool const serial_interface_2_status() const {return this -> data_.test(13);}
    bool const serial_interface_3_status() const {return this -> data_.test(14);}
    bool const ethernet_status() const {return this -> data_.test(15);}
    bool const baler_status() const {return this -> data_.test(16);}
    bool const dynamic_ip() const {return this -> data_.test(17);}
    bool const auxiliary_board_status() const {return this -> data_.test(18);}
    bool const serial_sensor_status() const {return this -> data_.test(19);}
    bool const environmental_processor_status() const {return this -> data_.test(20);}
    void global_status(const bool b) {this -> data_.set(0, b);}
    void gps_status(const bool b) {this -> data_.set(1, b);}
    void power_supply_status(const bool b) {this -> data_.set(2, b);}
    void boom_positions(const bool b) {this -> data_.set(3, b);}
    void thread_status(const bool b) {this -> data_.set(4, b);}
    void pll_status(const bool b) {this -> data_.set(5, b);}
    void gps_satellites(const bool b) {this -> data_.set(6, b);}
    void arp_status(const bool b) {this -> data_.set(7, b);}
    void data_port_1_status(const bool b) {this -> data_.set(8, b);}
    void data_port_2_status(const bool b) {this -> data_.set(9, b);}
    void data_port_3_status(const bool b) {this -> data_.set(10, b);}
    void data_port_4_status(const bool b) {this -> data_.set(11, b);}
    void serial_interface_1_status(const bool b) {this -> data_.set(12, b);}
    void serial_interface_2_status(const bool b) {this -> data_.set(13, b);}
    void serial_interface_3_status(const bool b) {this -> data_.set(14, b);}
    void ethernet_status(const bool b) {this -> data_.set(15, b);}
    void baler_status(const bool b) {this -> data_.set(16, b);}
    void dynamic_ip(const bool b) {this -> data_.set(17, b);}
    void auxiliary_board_status(const bool b) {this -> data_.set(18, b);}
    void serial_sensor_status(const bool b) {this -> data_.set(19, b);}
    void environmental_processor_status(const bool b) {this -> data_.set(20, b);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmRqstat const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.global_status() ) << "] " <<
        "global_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.gps_status() ) << "] " <<
        "gps_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.power_supply_status() ) << "] " <<
        "power_supply_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.boom_positions() ) << "] " <<
        "boom_positions";
    bm_os << "\n   [" << bm.bool_indicator( bm.thread_status() ) << "] " <<
        "thread_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.pll_status() ) << "] " <<
        "pll_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.gps_satellites() ) << "] " <<
        "gps_satellites";
    bm_os << "\n   [" << bm.bool_indicator( bm.arp_status() ) << "] " <<
        "arp_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.data_port_1_status() ) << "] " <<
        "data_port_1_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.data_port_2_status() ) << "] " <<
        "data_port_2_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.data_port_3_status() ) << "] " <<
        "data_port_3_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.data_port_4_status() ) << "] " <<
        "data_port_4_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.serial_interface_1_status() ) << "] " <<
        "serial_interface_1_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.serial_interface_2_status() ) << "] " <<
        "serial_interface_2_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.serial_interface_3_status() ) << "] " <<
        "serial_interface_3_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.ethernet_status() ) << "] " <<
        "ethernet_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.baler_status() ) << "] " <<
        "baler_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.dynamic_ip() ) << "] " <<
        "dynamic_ip";
    bm_os << "\n   [" << bm.bool_indicator( bm.auxiliary_board_status() ) << "] " <<
        "auxiliary_board_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.serial_sensor_status() ) << "] " <<
        "serial_sensor_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.environmental_processor_status() ) << "] " <<
        "environmental_processor_status";
    bm_os << "\n";
    return bm_os;
}

class BmSdidriver : public CmdFieldBitmap<1> {
friend std::ostream & operator<<(std::ostream & bm_os, BmSdidriver const & bm);

public:
    explicit BmSdidriver() : CmdFieldBitmap<1>{} {};

    enum class SdiDriver {
        vaisala_wxt520_weather_station = 1,
    };

    unsigned long const sdi_driver() const {return CmdFieldBitmap<1>::raw_value();}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmSdidriver const & bm) {
    bm_os << "\n";
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.sdi_driver();
    bm_os << "\n   sdi_driver : " << c << " : ";
    switch(c) {

    case 1 : {
         bm_os << "vaisala_wxt520_weather_station";
         break;}
    }
}
    bm_os << "\n";
    return bm_os;
}

class BmSdiphase : public CmdFieldBitmap<1> {
friend std::ostream & operator<<(std::ostream & bm_os, BmSdiphase const & bm);

public:
    explicit BmSdiphase() : CmdFieldBitmap<1>{} {};

    enum class SdiPhase {
        ready_to_run = 6,
        sampling = 7,
        waiting_for_sample_result = 8,
    };

    unsigned long const sdi_phase() const {return CmdFieldBitmap<1>::raw_value();}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmSdiphase const & bm) {
    bm_os << "\n";
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.sdi_phase();
    bm_os << "\n   sdi_phase : " << c << " : ";
    switch(c) {

    case 6 : {
         bm_os << "ready_to_run";
         break;}

    case 7 : {
         bm_os << "sampling";
         break;}

    case 8 : {
         bm_os << "waiting_for_sample_result";
         break;}
    }
}
    bm_os << "\n";
    return bm_os;
}

class BmSensorControlBitmap : public CmdFieldBitmap<4> {
friend std::ostream & operator<<(std::ostream & bm_os, BmSensorControlBitmap const & bm);

public:
    explicit BmSensorControlBitmap() : CmdFieldBitmap<4>{} {};

    enum class SensorControlMapping {
        not_doing_calibration_or_recentering = 0,
        sensor_a_calibration = 1,
        sensor_a_centering = 2,
        sensor_a_capacitive_coupling = 3,
        sensor_b_calibration = 4,
        sensor_b_centering = 5,
        sensor_b_capacitive_coupling = 6,
        sensor_a_lock = 7,
        sensor_a_unlock = 8,
        sensor_a_aux_1 = 9,
        sensor_a_aux_2 = 10,
        sensor_b_lock = 11,
        sensor_b_unlock = 12,
        sensor_b_aux_1 = 13,
        sensor_b_aux_2 = 14,
    };

    bool const active_high() const {return this -> data_.test(8);}
    unsigned long const sensor_control_mapping() const {return CmdFieldBitmap<4>::raw_value_from_range(0, 0x7F);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmSensorControlBitmap const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.active_high() ) << "] " <<
        "active_high";
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.sensor_control_mapping();
    bm_os << "\n   sensor_control_mapping : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "not_doing_calibration_or_recentering";
         break;}

    case 1 : {
         bm_os << "sensor_a_calibration";
         break;}

    case 2 : {
         bm_os << "sensor_a_centering";
         break;}

    case 3 : {
         bm_os << "sensor_a_capacitive_coupling";
         break;}

    case 4 : {
         bm_os << "sensor_b_calibration";
         break;}

    case 5 : {
         bm_os << "sensor_b_centering";
         break;}

    case 6 : {
         bm_os << "sensor_b_capacitive_coupling";
         break;}

    case 7 : {
         bm_os << "sensor_a_lock";
         break;}

    case 8 : {
         bm_os << "sensor_a_unlock";
         break;}

    case 9 : {
         bm_os << "sensor_a_aux_1";
         break;}

    case 10 : {
         bm_os << "sensor_a_aux_2";
         break;}

    case 11 : {
         bm_os << "sensor_b_lock";
         break;}

    case 12 : {
         bm_os << "sensor_b_unlock";
         break;}

    case 13 : {
         bm_os << "sensor_b_aux_1";
         break;}

    case 14 : {
         bm_os << "sensor_b_aux_2";
         break;}
    }
}
    bm_os << "\n";
    return bm_os;
}

class BmSerialsensorUnits : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmSerialsensorUnits const & bm);

public:
    explicit BmSerialsensorUnits() : CmdFieldBitmap<2>{} {};

    enum class PressureUnits {
        unknown = 0,
        psi = 1,
        hpa = 2,
        bar = 3,
        kpa = 4,
        mpa = 5,
        in_hg = 6,
        mm_hg = 7,
        m_h2o = 8,
    };

    unsigned long const pressure_units() const {return CmdFieldBitmap<2>::raw_value();}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmSerialsensorUnits const & bm) {
    bm_os << "\n";
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.pressure_units();
    bm_os << "\n   pressure_units : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "unknown";
         break;}

    case 1 : {
         bm_os << "psi";
         break;}

    case 2 : {
         bm_os << "hpa";
         break;}

    case 3 : {
         bm_os << "bar";
         break;}

    case 4 : {
         bm_os << "kpa";
         break;}

    case 5 : {
         bm_os << "mpa";
         break;}

    case 6 : {
         bm_os << "in_hg";
         break;}

    case 7 : {
         bm_os << "mm_hg";
         break;}

    case 8 : {
         bm_os << "m_h2o";
         break;}
    }
}
    bm_os << "\n";
    return bm_os;
}

class BmSerialsensorValidfields : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmSerialsensorValidfields const & bm);

public:
    explicit BmSerialsensorValidfields() : CmdFieldBitmap<2>{} {};
    bool const pressure_measurement_is_valid() const {return this -> data_.test(0);}
    bool const internal_temperature_measurement_is_valid() const {return this -> data_.test(1);}
    bool const humidity_measurement_is_valid() const {return this -> data_.test(2);}
    bool const external_temperature_measurement_is_valid() const {return this -> data_.test(3);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmSerialsensorValidfields const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.pressure_measurement_is_valid() ) << "] " <<
        "pressure_measurement_is_valid";
    bm_os << "\n   [" << bm.bool_indicator( bm.internal_temperature_measurement_is_valid() ) << "] " <<
        "internal_temperature_measurement_is_valid";
    bm_os << "\n   [" << bm.bool_indicator( bm.humidity_measurement_is_valid() ) << "] " <<
        "humidity_measurement_is_valid";
    bm_os << "\n   [" << bm.bool_indicator( bm.external_temperature_measurement_is_valid() ) << "] " <<
        "external_temperature_measurement_is_valid";
    bm_os << "\n";
    return bm_os;
}

class BmStatCalibratorStatus : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmStatCalibratorStatus const & bm);

public:
    explicit BmStatCalibratorStatus() : CmdFieldBitmap<2>{} {};
    bool const calibration_enable_is_on_this_second() const {return this -> data_.test(0);}
    bool const calibration_signal_is_on_this_second() const {return this -> data_.test(1);}
    bool const calibrator_should_be_generating_a_signal_but_isnt() const {return this -> data_.test(2);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmStatCalibratorStatus const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.calibration_enable_is_on_this_second() ) << "] " <<
        "calibration_enable_is_on_this_second";
    bm_os << "\n   [" << bm.bool_indicator( bm.calibration_signal_is_on_this_second() ) << "] " <<
        "calibration_signal_is_on_this_second";
    bm_os << "\n   [" << bm.bool_indicator( bm.calibrator_should_be_generating_a_signal_but_isnt() ) << "] " <<
        "calibrator_should_be_generating_a_signal_but_isnt";
    bm_os << "\n";
    return bm_os;
}

class BmStatClockQuality : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmStatClockQuality const & bm);

public:
    explicit BmStatClockQuality() : CmdFieldBitmap<2>{} {};

    enum class PllStatus {
        pll_not_enabled = 0,
        pll_hold = 1,
        pll_tracking = 2,
        pll_locked = 3,
    };

    bool const clock_has_ever_had_lock() const {return this -> data_.test(0);}
    bool const clock_currently_has_2d_lock() const {return this -> data_.test(1);}
    bool const clock_currently_has_3d_lock() const {return this -> data_.test(2);}
    bool const clock_currently_has_1d_lock() const {return this -> data_.test(3);}
    bool const timemarks_current_frozen_due_to_filtering() const {return this -> data_.test(4);}
    bool const speculative_lock_based_on_internal_clock() const {return this -> data_.test(5);}
    unsigned long const pll_status() const {return CmdFieldBitmap<2>::raw_value_from_range(6, 0x3);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmStatClockQuality const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.clock_has_ever_had_lock() ) << "] " <<
        "clock_has_ever_had_lock";
    bm_os << "\n   [" << bm.bool_indicator( bm.clock_currently_has_2d_lock() ) << "] " <<
        "clock_currently_has_2d_lock";
    bm_os << "\n   [" << bm.bool_indicator( bm.clock_currently_has_3d_lock() ) << "] " <<
        "clock_currently_has_3d_lock";
    bm_os << "\n   [" << bm.bool_indicator( bm.clock_currently_has_1d_lock() ) << "] " <<
        "clock_currently_has_1d_lock";
    bm_os << "\n   [" << bm.bool_indicator( bm.timemarks_current_frozen_due_to_filtering() ) << "] " <<
        "timemarks_current_frozen_due_to_filtering";
    bm_os << "\n   [" << bm.bool_indicator( bm.speculative_lock_based_on_internal_clock() ) << "] " <<
        "speculative_lock_based_on_internal_clock";
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.pll_status();
    bm_os << "\n   pll_status : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "pll_not_enabled";
         break;}

    case 1 : {
         bm_os << "pll_hold";
         break;}

    case 2 : {
         bm_os << "pll_tracking";
         break;}

    case 3 : {
         bm_os << "pll_locked";
         break;}
    }
}
    bm_os << "\n";
    return bm_os;
}

class BmStatSensorControlBitmap : public CmdFieldBitmap<2> {
friend std::ostream & operator<<(std::ostream & bm_os, BmStatSensorControlBitmap const & bm);

public:
    explicit BmStatSensorControlBitmap() : CmdFieldBitmap<2>{} {};

    enum class SensorControlMapping {
        not_doing_calibration_or_recentering = 0,
        sensor_a_calibration = 1,
        sensor_a_centering = 2,
        sensor_a_capacitive_coupling = 3,
        sensor_b_calibration = 4,
        sensor_b_centering = 5,
        sensor_b_capacitive_coupling = 6,
        sensor_a_lock = 7,
        sensor_a_unlock = 8,
        sensor_a_aux_1 = 9,
        sensor_a_aux_2 = 10,
        sensor_b_lock = 11,
        sensor_b_unlock = 12,
        sensor_b_aux_1 = 13,
        sensor_b_aux_2 = 14,
    };

    bool const active_high() const {return this -> data_.test(8);}
    unsigned long const sensor_control_mapping() const {return CmdFieldBitmap<2>::raw_value_from_range(0, 0x7F);}
    void active_high(const bool b) {this -> data_.set(8, b);}
    void sensor_control_mapping(SensorControlMapping const c) {CmdFieldBitmap<2>::set_raw_value_in_range(0, 0x7F, static_cast<unsigned long>(c) );}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmStatSensorControlBitmap const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.active_high() ) << "] " <<
        "active_high";
 // just in case there is more than one code in a bmf
 // as in BmAuxStatusWebFlags
{
    unsigned int c = bm.sensor_control_mapping();
    bm_os << "\n   sensor_control_mapping : " << c << " : ";
    switch(c) {

    case 0 : {
         bm_os << "not_doing_calibration_or_recentering";
         break;}

    case 1 : {
         bm_os << "sensor_a_calibration";
         break;}

    case 2 : {
         bm_os << "sensor_a_centering";
         break;}

    case 3 : {
         bm_os << "sensor_a_capacitive_coupling";
         break;}

    case 4 : {
         bm_os << "sensor_b_calibration";
         break;}

    case 5 : {
         bm_os << "sensor_b_centering";
         break;}

    case 6 : {
         bm_os << "sensor_b_capacitive_coupling";
         break;}

    case 7 : {
         bm_os << "sensor_a_lock";
         break;}

    case 8 : {
         bm_os << "sensor_a_unlock";
         break;}

    case 9 : {
         bm_os << "sensor_a_aux_1";
         break;}

    case 10 : {
         bm_os << "sensor_a_aux_2";
         break;}

    case 11 : {
         bm_os << "sensor_b_lock";
         break;}

    case 12 : {
         bm_os << "sensor_b_unlock";
         break;}

    case 13 : {
         bm_os << "sensor_b_aux_1";
         break;}

    case 14 : {
         bm_os << "sensor_b_aux_2";
         break;}
    }
}
    bm_os << "\n";
    return bm_os;
}

class BmStatStatusBitmap : public CmdFieldBitmap<4> {
friend std::ostream & operator<<(std::ostream & bm_os, BmStatStatusBitmap const & bm);

public:
    explicit BmStatStatusBitmap() : CmdFieldBitmap<4>{} {};
    bool const global_status() const {return this -> data_.test(0);}
    bool const gps_status() const {return this -> data_.test(1);}
    bool const power_supply_status() const {return this -> data_.test(2);}
    bool const boom_positions_temperatures_and_voltages() const {return this -> data_.test(3);}
    bool const thread_status() const {return this -> data_.test(4);}
    bool const pll_status() const {return this -> data_.test(5);}
    bool const gps_satellites() const {return this -> data_.test(6);}
    bool const arp_status() const {return this -> data_.test(7);}
    bool const data_port_1_status() const {return this -> data_.test(8);}
    bool const data_port_2_status() const {return this -> data_.test(9);}
    bool const data_port_3_status() const {return this -> data_.test(10);}
    bool const data_port_4_status() const {return this -> data_.test(11);}
    bool const serial_interface_1_status() const {return this -> data_.test(12);}
    bool const serial_interface_2_status() const {return this -> data_.test(13);}
    bool const serial_interface_3_status() const {return this -> data_.test(14);}
    bool const ethernet_status() const {return this -> data_.test(15);}
    bool const baler_status() const {return this -> data_.test(16);}
    bool const dynamic_ip_addresses() const {return this -> data_.test(17);}
    bool const auxiliary_board_status() const {return this -> data_.test(18);}
    bool const serial_sensor_status() const {return this -> data_.test(19);}
    bool const environmental_processor_status() const {return this -> data_.test(20);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmStatStatusBitmap const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.global_status() ) << "] " <<
        "global_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.gps_status() ) << "] " <<
        "gps_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.power_supply_status() ) << "] " <<
        "power_supply_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.boom_positions_temperatures_and_voltages() ) << "] " <<
        "boom_positions_temperatures_and_voltages";
    bm_os << "\n   [" << bm.bool_indicator( bm.thread_status() ) << "] " <<
        "thread_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.pll_status() ) << "] " <<
        "pll_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.gps_satellites() ) << "] " <<
        "gps_satellites";
    bm_os << "\n   [" << bm.bool_indicator( bm.arp_status() ) << "] " <<
        "arp_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.data_port_1_status() ) << "] " <<
        "data_port_1_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.data_port_2_status() ) << "] " <<
        "data_port_2_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.data_port_3_status() ) << "] " <<
        "data_port_3_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.data_port_4_status() ) << "] " <<
        "data_port_4_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.serial_interface_1_status() ) << "] " <<
        "serial_interface_1_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.serial_interface_2_status() ) << "] " <<
        "serial_interface_2_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.serial_interface_3_status() ) << "] " <<
        "serial_interface_3_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.ethernet_status() ) << "] " <<
        "ethernet_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.baler_status() ) << "] " <<
        "baler_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.dynamic_ip_addresses() ) << "] " <<
        "dynamic_ip_addresses";
    bm_os << "\n   [" << bm.bool_indicator( bm.auxiliary_board_status() ) << "] " <<
        "auxiliary_board_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.serial_sensor_status() ) << "] " <<
        "serial_sensor_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.environmental_processor_status() ) << "] " <<
        "environmental_processor_status";
    bm_os << "\n";
    return bm_os;
}
} // end of namespace
#endif // _MZN_CMD_FIELD_BITMAP_TYPES_H
