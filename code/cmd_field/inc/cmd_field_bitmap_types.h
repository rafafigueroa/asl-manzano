// ** Bitmap Classes ** //
// Autogenerated in main_create_bms.cpp from bm_format.json ** //
// Manzano Software //

#ifndef _MZN_CMD_FIELD_BITMAP_TYPES_H
#define _MZN_CMD_FIELD_BITMAP_TYPES_H

#include "cmd_field_bitmap.h"

namespace mzn {

// -------------------------------------------------------------------------- //
class BmAdcmodel : public CmdFieldBitmap<1> {

friend std::ostream & operator<<(std::ostream & bm_os, BmAdcmodel const & bm);

public:
    explicit BmAdcmodel() : CmdFieldBitmap<1>{} {};

    enum class AdcModel {
        no_adc_module_installed = 0,
        one_channel_adc_module_configured_for_setra_use = 1,
        generic_one_channel_adc_module = 2,
        generic_three_adc_module = 3,
    };

    AdcModel const adc_model() const {return static_cast<AdcModel>( CmdFieldBitmap<1>::raw_value() );}
};

//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmAdcmodel::AdcModel const & bmc) {
    using AdcModel = BmAdcmodel::AdcModel;
    bm_os << "\n   adc_model : ";
    switch(bmc) {

    case AdcModel::no_adc_module_installed : {
         bm_os << "no_adc_module_installed";
         break;}

    case AdcModel::one_channel_adc_module_configured_for_setra_use : {
         bm_os << "one_channel_adc_module_configured_for_setra_use";
         break;}

    case AdcModel::generic_one_channel_adc_module : {
         bm_os << "generic_one_channel_adc_module";
         break;}

    case AdcModel::generic_three_adc_module : {
         bm_os << "generic_three_adc_module";
         break;}
    } // end switch
    return bm_os;
}
inline std::ostream & operator<<(std::ostream & bm_os, BmAdcmodel const & bm) {
    bm_os << "\n";
    bm_os << bm.adc_model();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmAlerts : public CmdFieldBitmap<1> {

friend std::ostream & operator<<(std::ostream & bm_os, BmAlerts const & bm);

public:
    explicit BmAlerts() : CmdFieldBitmap<1>{} {};
    bool const load_0_will_be_off_after_delay() const {return this -> data_.test(0);}
    bool const load_1_will_be_off_after_delay() const {return this -> data_.test(1);}
    bool const load_2_will_be_off_after_delay() const {return this -> data_.test(2);}
    bool const load_3_will_be_off_after_delay() const {return this -> data_.test(3);}
    bool const load_4_will_be_off_after_delay() const {return this -> data_.test(4);}
    bool const load_5_will_be_off_after_delay() const {return this -> data_.test(5);}
    bool const load_6_will_be_off_after_delay() const {return this -> data_.test(6);}
    bool const load_7_will_be_off_after_delay() const {return this -> data_.test(7);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmAlerts const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_0_will_be_off_after_delay() ) << "] " <<
        "load_0_will_be_off_after_delay";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_1_will_be_off_after_delay() ) << "] " <<
        "load_1_will_be_off_after_delay";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_2_will_be_off_after_delay() ) << "] " <<
        "load_2_will_be_off_after_delay";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_3_will_be_off_after_delay() ) << "] " <<
        "load_3_will_be_off_after_delay";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_4_will_be_off_after_delay() ) << "] " <<
        "load_4_will_be_off_after_delay";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_5_will_be_off_after_delay() ) << "] " <<
        "load_5_will_be_off_after_delay";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_6_will_be_off_after_delay() ) << "] " <<
        "load_6_will_be_off_after_delay";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_7_will_be_off_after_delay() ) << "] " <<
        "load_7_will_be_off_after_delay";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmAuxStatusWebFlags : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmAuxStatusWebFlags const & bm);

public:
    explicit BmAuxStatusWebFlags() : CmdFieldBitmap<2>{} {};

    enum class AuxReportingInterval {
        not_reported = 0,
        one_hertz = 1,
    };


    enum class StatusPortReportingInterval {
        not_reported = 0,
        one_hertz = 1,
    };

    bool const allow_unauthenticated_baler_power_control_on_web_page() const {return this -> data_.test(2);}
    bool const allow_unauthenticated_baler_link_web_page() const {return this -> data_.test(3);}
    bool const show_q330_serial_number_on_web_page() const {return this -> data_.test(4);}
    AuxReportingInterval const aux_reporting_interval() const {return static_cast<AuxReportingInterval>( CmdFieldBitmap<2>::raw_value_from_range(0, 0x3) );}
    StatusPortReportingInterval const status_port_reporting_interval() const {return static_cast<StatusPortReportingInterval>( CmdFieldBitmap<2>::raw_value_from_range(8, 0x3) );}
};

//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmAuxStatusWebFlags::AuxReportingInterval const & bmc) {
    using AuxReportingInterval = BmAuxStatusWebFlags::AuxReportingInterval;
    bm_os << "\n   aux_reporting_interval : ";
    switch(bmc) {

    case AuxReportingInterval::not_reported : {
         bm_os << "not_reported";
         break;}

    case AuxReportingInterval::one_hertz : {
         bm_os << "one_hertz";
         break;}
    } // end switch
    return bm_os;
}
//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmAuxStatusWebFlags::StatusPortReportingInterval const & bmc) {
    using StatusPortReportingInterval = BmAuxStatusWebFlags::StatusPortReportingInterval;
    bm_os << "\n   status_port_reporting_interval : ";
    switch(bmc) {

    case StatusPortReportingInterval::not_reported : {
         bm_os << "not_reported";
         break;}

    case StatusPortReportingInterval::one_hertz : {
         bm_os << "one_hertz";
         break;}
    } // end switch
    return bm_os;
}
inline std::ostream & operator<<(std::ostream & bm_os, BmAuxStatusWebFlags const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.allow_unauthenticated_baler_power_control_on_web_page() ) << "] " <<
        "allow_unauthenticated_baler_power_control_on_web_page";
    bm_os << "\n   [" << bm.bool_indicator( bm.allow_unauthenticated_baler_link_web_page() ) << "] " <<
        "allow_unauthenticated_baler_link_web_page";
    bm_os << "\n   [" << bm.bool_indicator( bm.show_q330_serial_number_on_web_page() ) << "] " <<
        "show_q330_serial_number_on_web_page";
    bm_os << bm.aux_reporting_interval();
    bm_os << bm.status_port_reporting_interval();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmBalerstatus : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmBalerstatus const & bm);

public:
    explicit BmBalerstatus() : CmdFieldBitmap<2>{} {};

    enum class BalerPowerStatus {
        baler_off = 0,
        baler_power_turned_on_by_a_command = 1,
        baler_power_turned_on_automatically = 2,
        baler_power_is_continuous = 3,
    };

    const unsigned long timeout_counts() const {return CmdFieldBitmap<2>::raw_value_from_range(0, 0xFFF);}
    bool const baler_is_currently_forced_off_for_the_minimum_off_time() const {return this -> data_.test(12);}
    bool const set_to_one() const {return this -> data_.test(13);}
    BalerPowerStatus const baler_power_status() const {return static_cast<BalerPowerStatus>( CmdFieldBitmap<2>::raw_value_from_range(14, 0x3) );}
};

//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmBalerstatus::BalerPowerStatus const & bmc) {
    using BalerPowerStatus = BmBalerstatus::BalerPowerStatus;
    bm_os << "\n   baler_power_status : ";
    switch(bmc) {

    case BalerPowerStatus::baler_off : {
         bm_os << "baler_off";
         break;}

    case BalerPowerStatus::baler_power_turned_on_by_a_command : {
         bm_os << "baler_power_turned_on_by_a_command";
         break;}

    case BalerPowerStatus::baler_power_turned_on_automatically : {
         bm_os << "baler_power_turned_on_automatically";
         break;}

    case BalerPowerStatus::baler_power_is_continuous : {
         bm_os << "baler_power_is_continuous";
         break;}
    } // end switch
    return bm_os;
}
inline std::ostream & operator<<(std::ostream & bm_os, BmBalerstatus const & bm) {
    bm_os << "\n";
    bm_os << "\n   timeout_counts : " << bm.timeout_counts();
    bm_os << "\n   [" << bm.bool_indicator( bm.baler_is_currently_forced_off_for_the_minimum_off_time() ) << "] " <<
        "baler_is_currently_forced_off_for_the_minimum_off_time";
    bm_os << "\n   [" << bm.bool_indicator( bm.set_to_one() ) << "] " <<
        "set_to_one";
    bm_os << bm.baler_power_status();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmBalerstatusSpecial : public CmdFieldBitmap<4> {

friend std::ostream & operator<<(std::ostream & bm_os, BmBalerstatusSpecial const & bm);

public:
    explicit BmBalerstatusSpecial() : CmdFieldBitmap<4>{} {};
    bool const baler_is_connected_on_serial_1() const {return this -> data_.test(0);}
    bool const baler_is_connected_on_serial_2() const {return this -> data_.test(1);}
    bool const baler_is_connected_on_ethernet() const {return this -> data_.test(3);}
    bool const q330_will_accept_a_connection_on_serial_1_from_a_baler_assigned_to_another_q330() const {return this -> data_.test(4);}
    bool const q330_will_accept_a_connection_on_serial_2_from_a_baler_assigned_to_another_q330() const {return this -> data_.test(5);}
    bool const q330_will_accept_a_connection_on_ethernet_from_a_baler_assigned_to_another_q330() const {return this -> data_.test(7);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmBalerstatusSpecial const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.baler_is_connected_on_serial_1() ) << "] " <<
        "baler_is_connected_on_serial_1";
    bm_os << "\n   [" << bm.bool_indicator( bm.baler_is_connected_on_serial_2() ) << "] " <<
        "baler_is_connected_on_serial_2";
    bm_os << "\n   [" << bm.bool_indicator( bm.baler_is_connected_on_ethernet() ) << "] " <<
        "baler_is_connected_on_ethernet";
    bm_os << "\n   [" << bm.bool_indicator( bm.q330_will_accept_a_connection_on_serial_1_from_a_baler_assigned_to_another_q330() ) << "] " <<
        "q330_will_accept_a_connection_on_serial_1_from_a_baler_assigned_to_another_q330";
    bm_os << "\n   [" << bm.bool_indicator( bm.q330_will_accept_a_connection_on_serial_2_from_a_baler_assigned_to_another_q330() ) << "] " <<
        "q330_will_accept_a_connection_on_serial_2_from_a_baler_assigned_to_another_q330";
    bm_os << "\n   [" << bm.bool_indicator( bm.q330_will_accept_a_connection_on_ethernet_from_a_baler_assigned_to_another_q330() ) << "] " <<
        "q330_will_accept_a_connection_on_ethernet_from_a_baler_assigned_to_another_q330";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmCalFail : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmCalFail const & bm);

public:
    explicit BmCalFail() : CmdFieldBitmap<2>{} {};
    bool const channel_1_failed_calibration() const {return this -> data_.test(0);}
    bool const channel_2_failed_calibration() const {return this -> data_.test(1);}
    bool const channel_3_failed_calibration() const {return this -> data_.test(2);}
    bool const channel_4_failed_calibration() const {return this -> data_.test(3);}
    bool const channel_5_failed_calibration() const {return this -> data_.test(4);}
    bool const channel_6_failed_calibration() const {return this -> data_.test(5);}
    bool const channel_7_failed_calibration() const {return this -> data_.test(6);}
    bool const channel_8_failed_calibration() const {return this -> data_.test(7);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmCalFail const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_1_failed_calibration() ) << "] " <<
        "channel_1_failed_calibration";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_2_failed_calibration() ) << "] " <<
        "channel_2_failed_calibration";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_3_failed_calibration() ) << "] " <<
        "channel_3_failed_calibration";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_4_failed_calibration() ) << "] " <<
        "channel_4_failed_calibration";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_5_failed_calibration() ) << "] " <<
        "channel_5_failed_calibration";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_6_failed_calibration() ) << "] " <<
        "channel_6_failed_calibration";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_7_failed_calibration() ) << "] " <<
        "channel_7_failed_calibration";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_8_failed_calibration() ) << "] " <<
        "channel_8_failed_calibration";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmCalMonitorChannel : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmCalMonitorChannel const & bm);

public:
    explicit BmCalMonitorChannel() : CmdFieldBitmap<2>{} {};
    bool const channel_1() const {return this -> data_.test(0);}
    bool const channel_2() const {return this -> data_.test(1);}
    bool const channel_3() const {return this -> data_.test(2);}
    bool const channel_4() const {return this -> data_.test(3);}
    bool const channel_5() const {return this -> data_.test(4);}
    bool const channel_6() const {return this -> data_.test(5);}
    void channel_1(const bool b) {this -> data_.set(0, b);}
    void channel_2(const bool b) {this -> data_.set(1, b);}
    void channel_3(const bool b) {this -> data_.set(2, b);}
    void channel_4(const bool b) {this -> data_.set(3, b);}
    void channel_5(const bool b) {this -> data_.set(4, b);}
    void channel_6(const bool b) {this -> data_.set(5, b);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmCalMonitorChannel const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_1() ) << "] " <<
        "channel_1";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_2() ) << "] " <<
        "channel_2";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_3() ) << "] " <<
        "channel_3";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_4() ) << "] " <<
        "channel_4";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_5() ) << "] " <<
        "channel_5";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_6() ) << "] " <<
        "channel_6";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmCalSensorControlBitmap : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmCalSensorControlBitmap const & bm);

public:
    explicit BmCalSensorControlBitmap() : CmdFieldBitmap<2>{} {};
    bool const genen_1_a() const {return this -> data_.test(0);}
    bool const genen_2_a() const {return this -> data_.test(1);}
    bool const genen_3_a() const {return this -> data_.test(2);}
    bool const calen_a() const {return this -> data_.test(3);}
    bool const genen_1_b() const {return this -> data_.test(4);}
    bool const genen_2_b() const {return this -> data_.test(5);}
    bool const genen_3_b() const {return this -> data_.test(6);}
    bool const calen_b() const {return this -> data_.test(7);}
    void genen_1_a(const bool b) {this -> data_.set(0, b);}
    void genen_2_a(const bool b) {this -> data_.set(1, b);}
    void genen_3_a(const bool b) {this -> data_.set(2, b);}
    void calen_a(const bool b) {this -> data_.set(3, b);}
    void genen_1_b(const bool b) {this -> data_.set(4, b);}
    void genen_2_b(const bool b) {this -> data_.set(5, b);}
    void genen_3_b(const bool b) {this -> data_.set(6, b);}
    void calen_b(const bool b) {this -> data_.set(7, b);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmCalSensorControlBitmap const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.genen_1_a() ) << "] " <<
        "genen_1_a";
    bm_os << "\n   [" << bm.bool_indicator( bm.genen_2_a() ) << "] " <<
        "genen_2_a";
    bm_os << "\n   [" << bm.bool_indicator( bm.genen_3_a() ) << "] " <<
        "genen_3_a";
    bm_os << "\n   [" << bm.bool_indicator( bm.calen_a() ) << "] " <<
        "calen_a";
    bm_os << "\n   [" << bm.bool_indicator( bm.genen_1_b() ) << "] " <<
        "genen_1_b";
    bm_os << "\n   [" << bm.bool_indicator( bm.genen_2_b() ) << "] " <<
        "genen_2_b";
    bm_os << "\n   [" << bm.bool_indicator( bm.genen_3_b() ) << "] " <<
        "genen_3_b";
    bm_os << "\n   [" << bm.bool_indicator( bm.calen_b() ) << "] " <<
        "calen_b";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmCalWaveform : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmCalWaveform const & bm);

public:
    explicit BmCalWaveform() : CmdFieldBitmap<2>{} {};

    enum class Waveform {
        sine = 0,
        red_noise = 1,
        white_noise = 2,
        step = 3,
        random = 4,
    };

    bool const negative_step() const {return this -> data_.test(6);}
    bool const automatic_calibration() const {return this -> data_.test(7);}
    Waveform const waveform() const {return static_cast<Waveform>( CmdFieldBitmap<2>::raw_value_from_range(0, 0x7) );}
    void negative_step(const bool b) {this -> data_.set(6, b);}
    void automatic_calibration(const bool b) {this -> data_.set(7, b);}
    void waveform(Waveform const c) {CmdFieldBitmap<2>::set_raw_value_in_range(0, 0x7, static_cast<unsigned long>(c) );}
};

//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmCalWaveform::Waveform const & bmc) {
    using Waveform = BmCalWaveform::Waveform;
    bm_os << "\n   waveform : ";
    switch(bmc) {

    case Waveform::sine : {
         bm_os << "sine";
         break;}

    case Waveform::red_noise : {
         bm_os << "red_noise";
         break;}

    case Waveform::white_noise : {
         bm_os << "white_noise";
         break;}

    case Waveform::step : {
         bm_os << "step";
         break;}

    case Waveform::random : {
         bm_os << "random";
         break;}
    } // end switch
    return bm_os;
}
inline std::ostream & operator<<(std::ostream & bm_os, BmCalWaveform const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.negative_step() ) << "] " <<
        "negative_step";
    bm_os << "\n   [" << bm.bool_indicator( bm.automatic_calibration() ) << "] " <<
        "automatic_calibration";
    bm_os << bm.waveform();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmCalibrationBitmap : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmCalibrationBitmap const & bm);

public:
    explicit BmCalibrationBitmap() : CmdFieldBitmap<2>{} {};

    enum class Input {
        a = 3,
        b = 56,
    };

    Input const input() const {return static_cast<Input>( CmdFieldBitmap<2>::raw_value() );}
    void input(Input const c) {this -> data_ = std::bitset<16>( static_cast<unsigned long>(c) );}
};

//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmCalibrationBitmap::Input const & bmc) {
    using Input = BmCalibrationBitmap::Input;
    bm_os << "\n   input : ";
    switch(bmc) {

    case Input::a : {
         bm_os << "a";
         break;}

    case Input::b : {
         bm_os << "b";
         break;}
    } // end switch
    return bm_os;
}
inline std::ostream & operator<<(std::ostream & bm_os, BmCalibrationBitmap const & bm) {
    bm_os << "\n";
    bm_os << bm.input();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmCerr : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmCerr const & bm);

public:
    explicit BmCerr() : CmdFieldBitmap<2>{} {};

    enum class ErrorCode {
        no_permission_invalid_password = 0,
        too_many_configuration_or_special_functions = 1,
        you_are_not_registered = 2,
        invalid_registration_response = 3,
        parameter_error = 4,
        tried_to_read_an_eeprom_structure_that_is_not_valid = 5,
        configuration_only = 6,
        special_functions_port_only = 7,
        memory_operation_in_progress = 8,
        calibration_in_progress = 9,
        data_not_yet_available_for_quickview = 10,
        console_virtual_interface_only = 11,
        flash_write_or_erase_error = 12,
    };

    ErrorCode const error_code() const {return static_cast<ErrorCode>( CmdFieldBitmap<2>::raw_value() );}
};

//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmCerr::ErrorCode const & bmc) {
    using ErrorCode = BmCerr::ErrorCode;
    bm_os << "\n   error_code : ";
    switch(bmc) {

    case ErrorCode::no_permission_invalid_password : {
         bm_os << "no_permission_invalid_password";
         break;}

    case ErrorCode::too_many_configuration_or_special_functions : {
         bm_os << "too_many_configuration_or_special_functions";
         break;}

    case ErrorCode::you_are_not_registered : {
         bm_os << "you_are_not_registered";
         break;}

    case ErrorCode::invalid_registration_response : {
         bm_os << "invalid_registration_response";
         break;}

    case ErrorCode::parameter_error : {
         bm_os << "parameter_error";
         break;}

    case ErrorCode::tried_to_read_an_eeprom_structure_that_is_not_valid : {
         bm_os << "tried_to_read_an_eeprom_structure_that_is_not_valid";
         break;}

    case ErrorCode::configuration_only : {
         bm_os << "configuration_only";
         break;}

    case ErrorCode::special_functions_port_only : {
         bm_os << "special_functions_port_only";
         break;}

    case ErrorCode::memory_operation_in_progress : {
         bm_os << "memory_operation_in_progress";
         break;}

    case ErrorCode::calibration_in_progress : {
         bm_os << "calibration_in_progress";
         break;}

    case ErrorCode::data_not_yet_available_for_quickview : {
         bm_os << "data_not_yet_available_for_quickview";
         break;}

    case ErrorCode::console_virtual_interface_only : {
         bm_os << "console_virtual_interface_only";
         break;}

    case ErrorCode::flash_write_or_erase_error : {
         bm_os << "flash_write_or_erase_error";
         break;}
    } // end switch
    return bm_os;
}
inline std::ostream & operator<<(std::ostream & bm_os, BmCerr const & bm) {
    bm_os << "\n";
    bm_os << bm.error_code();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmChannelMap : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmChannelMap const & bm);

public:
    explicit BmChannelMap() : CmdFieldBitmap<2>{} {};
    bool const channel_1() const {return this -> data_.test(0);}
    bool const channel_2() const {return this -> data_.test(1);}
    bool const channel_3() const {return this -> data_.test(2);}
    bool const channel_4() const {return this -> data_.test(3);}
    bool const channel_5() const {return this -> data_.test(4);}
    bool const channel_6() const {return this -> data_.test(5);}
    void channel_1(const bool b) {this -> data_.set(0, b);}
    void channel_2(const bool b) {this -> data_.set(1, b);}
    void channel_3(const bool b) {this -> data_.set(2, b);}
    void channel_4(const bool b) {this -> data_.set(3, b);}
    void channel_5(const bool b) {this -> data_.set(4, b);}
    void channel_6(const bool b) {this -> data_.set(5, b);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmChannelMap const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_1() ) << "] " <<
        "channel_1";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_2() ) << "] " <<
        "channel_2";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_3() ) << "] " <<
        "channel_3";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_4() ) << "] " <<
        "channel_4";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_5() ) << "] " <<
        "channel_5";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_6() ) << "] " <<
        "channel_6";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmChargingPhase : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmChargingPhase const & bm);

public:
    explicit BmChargingPhase() : CmdFieldBitmap<2>{} {};

    enum class ChargingPhase {
        not_charging = 0,
        bulk = 1,
        absorption = 2,
        float_phase = 3,
        equalization = 4,
    };

    ChargingPhase const charging_phase() const {return static_cast<ChargingPhase>( CmdFieldBitmap<2>::raw_value() );}
};

//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmChargingPhase::ChargingPhase const & bmc) {
    using ChargingPhase = BmChargingPhase::ChargingPhase;
    bm_os << "\n   charging_phase : ";
    switch(bmc) {

    case ChargingPhase::not_charging : {
         bm_os << "not_charging";
         break;}

    case ChargingPhase::bulk : {
         bm_os << "bulk";
         break;}

    case ChargingPhase::absorption : {
         bm_os << "absorption";
         break;}

    case ChargingPhase::float_phase : {
         bm_os << "float_phase";
         break;}

    case ChargingPhase::equalization : {
         bm_os << "equalization";
         break;}
    } // end switch
    return bm_os;
}
inline std::ostream & operator<<(std::ostream & bm_os, BmChargingPhase const & bm) {
    bm_os << "\n";
    bm_os << bm.charging_phase();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmCtrlFlags : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmCtrlFlags const & bm);

public:
    explicit BmCtrlFlags() : CmdFieldBitmap<2>{} {};
    bool const save_current_programming_to_eeprom() const {return this -> data_.test(0);}
    bool const reboot() const {return this -> data_.test(1);}
    bool const re_sync() const {return this -> data_.test(2);}
    bool const turn_gps_on() const {return this -> data_.test(3);}
    bool const turn_gps_off() const {return this -> data_.test(4);}
    bool const cold_start_gps() const {return this -> data_.test(5);}
    bool const reboot_envproc_on_serial_1() const {return this -> data_.test(6);}
    bool const reboot_envproc_on_serial_2() const {return this -> data_.test(7);}
    void save_current_programming_to_eeprom(const bool b) {this -> data_.set(0, b);}
    void reboot(const bool b) {this -> data_.set(1, b);}
    void re_sync(const bool b) {this -> data_.set(2, b);}
    void turn_gps_on(const bool b) {this -> data_.set(3, b);}
    void turn_gps_off(const bool b) {this -> data_.set(4, b);}
    void cold_start_gps(const bool b) {this -> data_.set(5, b);}
    void reboot_envproc_on_serial_1(const bool b) {this -> data_.set(6, b);}
    void reboot_envproc_on_serial_2(const bool b) {this -> data_.set(7, b);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmCtrlFlags const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.save_current_programming_to_eeprom() ) << "] " <<
        "save_current_programming_to_eeprom";
    bm_os << "\n   [" << bm.bool_indicator( bm.reboot() ) << "] " <<
        "reboot";
    bm_os << "\n   [" << bm.bool_indicator( bm.re_sync() ) << "] " <<
        "re_sync";
    bm_os << "\n   [" << bm.bool_indicator( bm.turn_gps_on() ) << "] " <<
        "turn_gps_on";
    bm_os << "\n   [" << bm.bool_indicator( bm.turn_gps_off() ) << "] " <<
        "turn_gps_off";
    bm_os << "\n   [" << bm.bool_indicator( bm.cold_start_gps() ) << "] " <<
        "cold_start_gps";
    bm_os << "\n   [" << bm.bool_indicator( bm.reboot_envproc_on_serial_1() ) << "] " <<
        "reboot_envproc_on_serial_1";
    bm_os << "\n   [" << bm.bool_indicator( bm.reboot_envproc_on_serial_2() ) << "] " <<
        "reboot_envproc_on_serial_2";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmDevOpt : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmDevOpt const & bm);

public:
    explicit BmDevOpt() : CmdFieldBitmap<2>{} {};
    bool const polling_for_data_status_enabled() const {return this -> data_.test(0);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmDevOpt const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.polling_for_data_status_enabled() ) << "] " <<
        "polling_for_data_status_enabled";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmDevUnitid : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmDevUnitid const & bm);

public:
    explicit BmDevUnitid() : CmdFieldBitmap<2>{} {};

    enum class UnitId {
        sp1320_power_supply = 13,
        power_supply_1 = 15,
        power_supply_2 = 17,
        power_supply_3 = 19,
        black_and_white_camera = 20,
        qcal_calibrator = 33,
        whoi_controller = 99,
    };

    UnitId const unit_id() const {return static_cast<UnitId>( CmdFieldBitmap<2>::raw_value() );}
};

//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmDevUnitid::UnitId const & bmc) {
    using UnitId = BmDevUnitid::UnitId;
    bm_os << "\n   unit_id : ";
    switch(bmc) {

    case UnitId::sp1320_power_supply : {
         bm_os << "sp1320_power_supply";
         break;}

    case UnitId::power_supply_1 : {
         bm_os << "power_supply_1";
         break;}

    case UnitId::power_supply_2 : {
         bm_os << "power_supply_2";
         break;}

    case UnitId::power_supply_3 : {
         bm_os << "power_supply_3";
         break;}

    case UnitId::black_and_white_camera : {
         bm_os << "black_and_white_camera";
         break;}

    case UnitId::qcal_calibrator : {
         bm_os << "qcal_calibrator";
         break;}

    case UnitId::whoi_controller : {
         bm_os << "whoi_controller";
         break;}
    } // end switch
    return bm_os;
}
inline std::ostream & operator<<(std::ostream & bm_os, BmDevUnitid const & bm) {
    bm_os << "\n";
    bm_os << bm.unit_id();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmEthernetLinkstatus : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmEthernetLinkstatus const & bm);

public:
    explicit BmEthernetLinkstatus() : CmdFieldBitmap<2>{} {};
    bool const polarity_ok() const {return this -> data_.test(4);}
    bool const link_ok() const {return this -> data_.test(15);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmEthernetLinkstatus const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.polarity_ok() ) << "] " <<
        "polarity_ok";
    bm_os << "\n   [" << bm.bool_indicator( bm.link_ok() ) << "] " <<
        "link_ok";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmFgDataport : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmFgDataport const & bm);

public:
    explicit BmFgDataport() : CmdFieldBitmap<2>{} {};
    bool const baler_should_disconnect_and_prepare_to_reconnect_to_a_data_vacuum() const {return this -> data_.test(0);}
    bool const baler_should_stay_powered_on() const {return this -> data_.test(1);}
    bool const baler_should_shutdown_immediately() const {return this -> data_.test(2);}
    bool const packet_memory_reduced_due_to_bad_packet_memory_ram() const {return this -> data_.test(15);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmFgDataport const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.baler_should_disconnect_and_prepare_to_reconnect_to_a_data_vacuum() ) << "] " <<
        "baler_should_disconnect_and_prepare_to_reconnect_to_a_data_vacuum";
    bm_os << "\n   [" << bm.bool_indicator( bm.baler_should_stay_powered_on() ) << "] " <<
        "baler_should_stay_powered_on";
    bm_os << "\n   [" << bm.bool_indicator( bm.baler_should_shutdown_immediately() ) << "] " <<
        "baler_should_shutdown_immediately";
    bm_os << "\n   [" << bm.bool_indicator( bm.packet_memory_reduced_due_to_bad_packet_memory_ram() ) << "] " <<
        "packet_memory_reduced_due_to_bad_packet_memory_ram";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmFgEnvironmental : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmFgEnvironmental const & bm);

public:
    explicit BmFgEnvironmental() : CmdFieldBitmap<2>{} {};
    bool const flash_manufacturing_constants_are_not_valid() const {return this -> data_.test(0);}
    bool const aux_io_line_1_is_active() const {return this -> data_.test(1);}
    bool const aux_io_line_2_is_active() const {return this -> data_.test(2);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmFgEnvironmental const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.flash_manufacturing_constants_are_not_valid() ) << "] " <<
        "flash_manufacturing_constants_are_not_valid";
    bm_os << "\n   [" << bm.bool_indicator( bm.aux_io_line_1_is_active() ) << "] " <<
        "aux_io_line_1_is_active";
    bm_os << "\n   [" << bm.bool_indicator( bm.aux_io_line_2_is_active() ) << "] " <<
        "aux_io_line_2_is_active";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmFgFix : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmFgFix const & bm);

public:
    explicit BmFgFix() : CmdFieldBitmap<2>{} {};
    bool const ethernet_installed() const {return this -> data_.test(0);}
    bool const can_statreq_dynamic_ip() const {return this -> data_.test(1);}
    bool const can_statreq_auxiliary_board() const {return this -> data_.test(2);}
    bool const can_expanded_c1_web_cmds() const {return this -> data_.test(3);}
    bool const can_statreq_serial_sensor() const {return this -> data_.test(4);}
    bool const can_report_255maplus_supply_current() const {return this -> data_.test(5);}
    bool const at_least_one_environmental_proc_configured() const {return this -> data_.test(6);}
    bool const is_Q330S() const {return this -> data_.test(7);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmFgFix const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.ethernet_installed() ) << "] " <<
        "ethernet_installed";
    bm_os << "\n   [" << bm.bool_indicator( bm.can_statreq_dynamic_ip() ) << "] " <<
        "can_statreq_dynamic_ip";
    bm_os << "\n   [" << bm.bool_indicator( bm.can_statreq_auxiliary_board() ) << "] " <<
        "can_statreq_auxiliary_board";
    bm_os << "\n   [" << bm.bool_indicator( bm.can_expanded_c1_web_cmds() ) << "] " <<
        "can_expanded_c1_web_cmds";
    bm_os << "\n   [" << bm.bool_indicator( bm.can_statreq_serial_sensor() ) << "] " <<
        "can_statreq_serial_sensor";
    bm_os << "\n   [" << bm.bool_indicator( bm.can_report_255maplus_supply_current() ) << "] " <<
        "can_report_255maplus_supply_current";
    bm_os << "\n   [" << bm.bool_indicator( bm.at_least_one_environmental_proc_configured() ) << "] " <<
        "at_least_one_environmental_proc_configured";
    bm_os << "\n   [" << bm.bool_indicator( bm.is_Q330S() ) << "] " <<
        "is_Q330S";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmFgSphy : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmFgSphy const & bm);

public:
    explicit BmFgSphy() : CmdFieldBitmap<2>{} {};
    bool const fill_mode_enabled() const {return this -> data_.test(0);}
    bool const flush_packet_buffer_time_based() const {return this -> data_.test(1);}
    bool const freeze_data_port_output() const {return this -> data_.test(2);}
    bool const freeze_packet_buff_input() const {return this -> data_.test(3);}
    bool const keep_oldest_data_packet_buffer() const {return this -> data_.test(4);}
    bool const dp_piggyback_statreq_with_dt_dack() const {return this -> data_.test(8);}
    bool const comm_fault_led_if_last_flush_buff_5plus() const {return this -> data_.test(9);}
    bool const allow_hotswap_on_this_dataport() const {return this -> data_.test(10);}
    bool const flush_sliding_window_buff_based_on_time() const {return this -> data_.test(11);}
    bool const send_datapackets_encoded_base_96() const {return this -> data_.test(14);}
    bool const save_changes_in_eeprom() const {return this -> data_.test(15);}
    void fill_mode_enabled(const bool b) {this -> data_.set(0, b);}
    void flush_packet_buffer_time_based(const bool b) {this -> data_.set(1, b);}
    void freeze_data_port_output(const bool b) {this -> data_.set(2, b);}
    void freeze_packet_buff_input(const bool b) {this -> data_.set(3, b);}
    void keep_oldest_data_packet_buffer(const bool b) {this -> data_.set(4, b);}
    void dp_piggyback_statreq_with_dt_dack(const bool b) {this -> data_.set(8, b);}
    void comm_fault_led_if_last_flush_buff_5plus(const bool b) {this -> data_.set(9, b);}
    void allow_hotswap_on_this_dataport(const bool b) {this -> data_.set(10, b);}
    void flush_sliding_window_buff_based_on_time(const bool b) {this -> data_.set(11, b);}
    void send_datapackets_encoded_base_96(const bool b) {this -> data_.set(14, b);}
    void save_changes_in_eeprom(const bool b) {this -> data_.set(15, b);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmFgSphy const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.fill_mode_enabled() ) << "] " <<
        "fill_mode_enabled";
    bm_os << "\n   [" << bm.bool_indicator( bm.flush_packet_buffer_time_based() ) << "] " <<
        "flush_packet_buffer_time_based";
    bm_os << "\n   [" << bm.bool_indicator( bm.freeze_data_port_output() ) << "] " <<
        "freeze_data_port_output";
    bm_os << "\n   [" << bm.bool_indicator( bm.freeze_packet_buff_input() ) << "] " <<
        "freeze_packet_buff_input";
    bm_os << "\n   [" << bm.bool_indicator( bm.keep_oldest_data_packet_buffer() ) << "] " <<
        "keep_oldest_data_packet_buffer";
    bm_os << "\n   [" << bm.bool_indicator( bm.dp_piggyback_statreq_with_dt_dack() ) << "] " <<
        "dp_piggyback_statreq_with_dt_dack";
    bm_os << "\n   [" << bm.bool_indicator( bm.comm_fault_led_if_last_flush_buff_5plus() ) << "] " <<
        "comm_fault_led_if_last_flush_buff_5plus";
    bm_os << "\n   [" << bm.bool_indicator( bm.allow_hotswap_on_this_dataport() ) << "] " <<
        "allow_hotswap_on_this_dataport";
    bm_os << "\n   [" << bm.bool_indicator( bm.flush_sliding_window_buff_based_on_time() ) << "] " <<
        "flush_sliding_window_buff_based_on_time";
    bm_os << "\n   [" << bm.bool_indicator( bm.send_datapackets_encoded_base_96() ) << "] " <<
        "send_datapackets_encoded_base_96";
    bm_os << "\n   [" << bm.bool_indicator( bm.save_changes_in_eeprom() ) << "] " <<
        "save_changes_in_eeprom";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmFgThread : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmFgThread const & bm);

public:
    explicit BmFgThread() : CmdFieldBitmap<2>{} {};
    const unsigned long global_event_value() const {return CmdFieldBitmap<2>::raw_value_from_range(0, 0x1FFF);}
    bool const global_event() const {return this -> data_.test(13);}
    bool const thread_is_waiting_for_an_event() const {return this -> data_.test(14);}
    bool const thread_is_blocked() const {return this -> data_.test(15);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmFgThread const & bm) {
    bm_os << "\n";
    bm_os << "\n   global_event_value : " << bm.global_event_value();
    bm_os << "\n   [" << bm.bool_indicator( bm.global_event() ) << "] " <<
        "global_event";
    bm_os << "\n   [" << bm.bool_indicator( bm.thread_is_waiting_for_an_event() ) << "] " <<
        "thread_is_waiting_for_an_event";
    bm_os << "\n   [" << bm.bool_indicator( bm.thread_is_blocked() ) << "] " <<
        "thread_is_blocked";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmFirmwareversion : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmFirmwareversion const & bm);

public:
    explicit BmFirmwareversion() : CmdFieldBitmap<2>{} {};
    const unsigned long firmware_version() const {return CmdFieldBitmap<2>::raw_value_from_range(8, 0xFF);}
    const unsigned long firmware_revision() const {return CmdFieldBitmap<2>::raw_value_from_range(0, 0xFF);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmFirmwareversion const & bm) {
    bm_os << "\n";
    bm_os << "\n   firmware_version : " << bm.firmware_version();
    bm_os << "\n   firmware_revision : " << bm.firmware_revision();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmGainPreAmp : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmGainPreAmp const & bm);

public:
    explicit BmGainPreAmp() : CmdFieldBitmap<2>{} {};

    enum class GainPreAmpChannel1 {
        disabled = 0,
        pre_amp_off = 1,
        pre_amp_on = 2,
    };


    enum class GainPreAmpChannel2 {
        disabled = 0,
        pre_amp_off = 1,
        pre_amp_on = 2,
    };


    enum class GainPreAmpChannel3 {
        disabled = 0,
        pre_amp_off = 1,
        pre_amp_on = 2,
    };


    enum class GainPreAmpChannel4 {
        disabled = 0,
        pre_amp_off = 1,
        pre_amp_on = 2,
    };


    enum class GainPreAmpChannel5 {
        disabled = 0,
        pre_amp_off = 1,
        pre_amp_on = 2,
    };


    enum class GainPreAmpChannel6 {
        disabled = 0,
        pre_amp_off = 1,
        pre_amp_on = 2,
    };

    GainPreAmpChannel1 const gain_pre_amp_channel_1() const {return static_cast<GainPreAmpChannel1>( CmdFieldBitmap<2>::raw_value_from_range(0, 0x3) );}
    GainPreAmpChannel2 const gain_pre_amp_channel_2() const {return static_cast<GainPreAmpChannel2>( CmdFieldBitmap<2>::raw_value_from_range(2, 0x3) );}
    GainPreAmpChannel3 const gain_pre_amp_channel_3() const {return static_cast<GainPreAmpChannel3>( CmdFieldBitmap<2>::raw_value_from_range(4, 0x3) );}
    GainPreAmpChannel4 const gain_pre_amp_channel_4() const {return static_cast<GainPreAmpChannel4>( CmdFieldBitmap<2>::raw_value_from_range(6, 0x3) );}
    GainPreAmpChannel5 const gain_pre_amp_channel_5() const {return static_cast<GainPreAmpChannel5>( CmdFieldBitmap<2>::raw_value_from_range(8, 0x3) );}
    GainPreAmpChannel6 const gain_pre_amp_channel_6() const {return static_cast<GainPreAmpChannel6>( CmdFieldBitmap<2>::raw_value_from_range(10, 0x3) );}
};

//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmGainPreAmp::GainPreAmpChannel1 const & bmc) {
    using GainPreAmpChannel1 = BmGainPreAmp::GainPreAmpChannel1;
    bm_os << "\n   gain_pre_amp_channel_1 : ";
    switch(bmc) {

    case GainPreAmpChannel1::disabled : {
         bm_os << "disabled";
         break;}

    case GainPreAmpChannel1::pre_amp_off : {
         bm_os << "pre_amp_off";
         break;}

    case GainPreAmpChannel1::pre_amp_on : {
         bm_os << "pre_amp_on";
         break;}
    } // end switch
    return bm_os;
}
//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmGainPreAmp::GainPreAmpChannel2 const & bmc) {
    using GainPreAmpChannel2 = BmGainPreAmp::GainPreAmpChannel2;
    bm_os << "\n   gain_pre_amp_channel_2 : ";
    switch(bmc) {

    case GainPreAmpChannel2::disabled : {
         bm_os << "disabled";
         break;}

    case GainPreAmpChannel2::pre_amp_off : {
         bm_os << "pre_amp_off";
         break;}

    case GainPreAmpChannel2::pre_amp_on : {
         bm_os << "pre_amp_on";
         break;}
    } // end switch
    return bm_os;
}
//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmGainPreAmp::GainPreAmpChannel3 const & bmc) {
    using GainPreAmpChannel3 = BmGainPreAmp::GainPreAmpChannel3;
    bm_os << "\n   gain_pre_amp_channel_3 : ";
    switch(bmc) {

    case GainPreAmpChannel3::disabled : {
         bm_os << "disabled";
         break;}

    case GainPreAmpChannel3::pre_amp_off : {
         bm_os << "pre_amp_off";
         break;}

    case GainPreAmpChannel3::pre_amp_on : {
         bm_os << "pre_amp_on";
         break;}
    } // end switch
    return bm_os;
}
//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmGainPreAmp::GainPreAmpChannel4 const & bmc) {
    using GainPreAmpChannel4 = BmGainPreAmp::GainPreAmpChannel4;
    bm_os << "\n   gain_pre_amp_channel_4 : ";
    switch(bmc) {

    case GainPreAmpChannel4::disabled : {
         bm_os << "disabled";
         break;}

    case GainPreAmpChannel4::pre_amp_off : {
         bm_os << "pre_amp_off";
         break;}

    case GainPreAmpChannel4::pre_amp_on : {
         bm_os << "pre_amp_on";
         break;}
    } // end switch
    return bm_os;
}
//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmGainPreAmp::GainPreAmpChannel5 const & bmc) {
    using GainPreAmpChannel5 = BmGainPreAmp::GainPreAmpChannel5;
    bm_os << "\n   gain_pre_amp_channel_5 : ";
    switch(bmc) {

    case GainPreAmpChannel5::disabled : {
         bm_os << "disabled";
         break;}

    case GainPreAmpChannel5::pre_amp_off : {
         bm_os << "pre_amp_off";
         break;}

    case GainPreAmpChannel5::pre_amp_on : {
         bm_os << "pre_amp_on";
         break;}
    } // end switch
    return bm_os;
}
//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmGainPreAmp::GainPreAmpChannel6 const & bmc) {
    using GainPreAmpChannel6 = BmGainPreAmp::GainPreAmpChannel6;
    bm_os << "\n   gain_pre_amp_channel_6 : ";
    switch(bmc) {

    case GainPreAmpChannel6::disabled : {
         bm_os << "disabled";
         break;}

    case GainPreAmpChannel6::pre_amp_off : {
         bm_os << "pre_amp_off";
         break;}

    case GainPreAmpChannel6::pre_amp_on : {
         bm_os << "pre_amp_on";
         break;}
    } // end switch
    return bm_os;
}
inline std::ostream & operator<<(std::ostream & bm_os, BmGainPreAmp const & bm) {
    bm_os << "\n";
    bm_os << bm.gain_pre_amp_channel_1();
    bm_os << bm.gain_pre_amp_channel_2();
    bm_os << bm.gain_pre_amp_channel_3();
    bm_os << bm.gain_pre_amp_channel_4();
    bm_os << bm.gain_pre_amp_channel_5();
    bm_os << bm.gain_pre_amp_channel_6();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmInitialVco : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmInitialVco const & bm);

public:
    explicit BmInitialVco() : CmdFieldBitmap<2>{} {};
    bool const automatic_vco_setting_by_pll() const {return this -> data_.test(15);}
    const unsigned long initial_vco() const {return CmdFieldBitmap<2>::raw_value_from_range(0, 0xFFF);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmInitialVco const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.automatic_vco_setting_by_pll() ) << "] " <<
        "automatic_vco_setting_by_pll";
    bm_os << "\n   initial_vco : " << bm.initial_vco();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmInputBitmap : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmInputBitmap const & bm);

public:
    explicit BmInputBitmap() : CmdFieldBitmap<2>{} {};

    enum class InputAType {
        one_pps_input = 0,
        reference_input = 1,
        calibrator_output = 2,
        grounded_input = 3,
    };


    enum class InputBType {
        one_pps_input = 0,
        reference_input = 1,
        calibrator_output = 2,
        grounded_input = 3,
    };

    bool const channel_1_uses_mux_special_input() const {return this -> data_.test(0);}
    bool const channel_2_uses_mux_special_input() const {return this -> data_.test(1);}
    bool const channel_3_uses_mux_special_input() const {return this -> data_.test(2);}
    bool const channel_4_uses_mux_special_input() const {return this -> data_.test(3);}
    bool const channel_5_uses_mux_special_input() const {return this -> data_.test(4);}
    bool const channel_6_uses_mux_special_input() const {return this -> data_.test(5);}
    InputAType const input_a_type() const {return static_cast<InputAType>( CmdFieldBitmap<2>::raw_value_from_range(8, 0x3) );}
    InputBType const input_b_type() const {return static_cast<InputBType>( CmdFieldBitmap<2>::raw_value_from_range(10, 0x3) );}
};

//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmInputBitmap::InputAType const & bmc) {
    using InputAType = BmInputBitmap::InputAType;
    bm_os << "\n   input_a_type : ";
    switch(bmc) {

    case InputAType::one_pps_input : {
         bm_os << "one_pps_input";
         break;}

    case InputAType::reference_input : {
         bm_os << "reference_input";
         break;}

    case InputAType::calibrator_output : {
         bm_os << "calibrator_output";
         break;}

    case InputAType::grounded_input : {
         bm_os << "grounded_input";
         break;}
    } // end switch
    return bm_os;
}
//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmInputBitmap::InputBType const & bmc) {
    using InputBType = BmInputBitmap::InputBType;
    bm_os << "\n   input_b_type : ";
    switch(bmc) {

    case InputBType::one_pps_input : {
         bm_os << "one_pps_input";
         break;}

    case InputBType::reference_input : {
         bm_os << "reference_input";
         break;}

    case InputBType::calibrator_output : {
         bm_os << "calibrator_output";
         break;}

    case InputBType::grounded_input : {
         bm_os << "grounded_input";
         break;}
    } // end switch
    return bm_os;
}
inline std::ostream & operator<<(std::ostream & bm_os, BmInputBitmap const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_1_uses_mux_special_input() ) << "] " <<
        "channel_1_uses_mux_special_input";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_2_uses_mux_special_input() ) << "] " <<
        "channel_2_uses_mux_special_input";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_3_uses_mux_special_input() ) << "] " <<
        "channel_3_uses_mux_special_input";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_4_uses_mux_special_input() ) << "] " <<
        "channel_4_uses_mux_special_input";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_5_uses_mux_special_input() ) << "] " <<
        "channel_5_uses_mux_special_input";
    bm_os << "\n   [" << bm.bool_indicator( bm.channel_6_uses_mux_special_input() ) << "] " <<
        "channel_6_uses_mux_special_input";
    bm_os << bm.input_a_type();
    bm_os << bm.input_b_type();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmLinearPhaseFilters : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmLinearPhaseFilters const & bm);

public:
    explicit BmLinearPhaseFilters() : CmdFieldBitmap<2>{} {};

    enum class LinearPhaseFiltersInputA {
        for_all_frequencies = 0,
        below_100Hz = 1,
        below_40Hz = 2,
        below_20Hz = 3,
    };


    enum class LinearPhaseFiltersInputB {
        for_all_frequencies = 0,
        below_100Hz = 1,
        below_40Hz = 2,
        below_20Hz = 3,
    };

    LinearPhaseFiltersInputA const linear_phase_filters_input_a() const {return static_cast<LinearPhaseFiltersInputA>( CmdFieldBitmap<2>::raw_value_from_range(0, 0x3) );}
    LinearPhaseFiltersInputB const linear_phase_filters_input_b() const {return static_cast<LinearPhaseFiltersInputB>( CmdFieldBitmap<2>::raw_value_from_range(2, 0x3) );}
};

//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmLinearPhaseFilters::LinearPhaseFiltersInputA const & bmc) {
    using LinearPhaseFiltersInputA = BmLinearPhaseFilters::LinearPhaseFiltersInputA;
    bm_os << "\n   linear_phase_filters_input_a : ";
    switch(bmc) {

    case LinearPhaseFiltersInputA::for_all_frequencies : {
         bm_os << "for_all_frequencies";
         break;}

    case LinearPhaseFiltersInputA::below_100Hz : {
         bm_os << "below_100Hz";
         break;}

    case LinearPhaseFiltersInputA::below_40Hz : {
         bm_os << "below_40Hz";
         break;}

    case LinearPhaseFiltersInputA::below_20Hz : {
         bm_os << "below_20Hz";
         break;}
    } // end switch
    return bm_os;
}
//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmLinearPhaseFilters::LinearPhaseFiltersInputB const & bmc) {
    using LinearPhaseFiltersInputB = BmLinearPhaseFilters::LinearPhaseFiltersInputB;
    bm_os << "\n   linear_phase_filters_input_b : ";
    switch(bmc) {

    case LinearPhaseFiltersInputB::for_all_frequencies : {
         bm_os << "for_all_frequencies";
         break;}

    case LinearPhaseFiltersInputB::below_100Hz : {
         bm_os << "below_100Hz";
         break;}

    case LinearPhaseFiltersInputB::below_40Hz : {
         bm_os << "below_40Hz";
         break;}

    case LinearPhaseFiltersInputB::below_20Hz : {
         bm_os << "below_20Hz";
         break;}
    } // end switch
    return bm_os;
}
inline std::ostream & operator<<(std::ostream & bm_os, BmLinearPhaseFilters const & bm) {
    bm_os << "\n";
    bm_os << bm.linear_phase_filters_input_a();
    bm_os << bm.linear_phase_filters_input_b();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmLoadsOff : public CmdFieldBitmap<1> {

friend std::ostream & operator<<(std::ostream & bm_os, BmLoadsOff const & bm);

public:
    explicit BmLoadsOff() : CmdFieldBitmap<1>{} {};
    bool const load_0_is_currently_off() const {return this -> data_.test(0);}
    bool const load_1_is_currently_off() const {return this -> data_.test(1);}
    bool const load_2_is_currently_off() const {return this -> data_.test(2);}
    bool const load_3_is_currently_off() const {return this -> data_.test(3);}
    bool const load_4_is_currently_off() const {return this -> data_.test(4);}
    bool const load_5_is_currently_off() const {return this -> data_.test(5);}
    bool const load_6_is_currently_off() const {return this -> data_.test(6);}
    bool const load_7_is_currently_off() const {return this -> data_.test(7);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmLoadsOff const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_0_is_currently_off() ) << "] " <<
        "load_0_is_currently_off";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_1_is_currently_off() ) << "] " <<
        "load_1_is_currently_off";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_2_is_currently_off() ) << "] " <<
        "load_2_is_currently_off";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_3_is_currently_off() ) << "] " <<
        "load_3_is_currently_off";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_4_is_currently_off() ) << "] " <<
        "load_4_is_currently_off";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_5_is_currently_off() ) << "] " <<
        "load_5_is_currently_off";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_6_is_currently_off() ) << "] " <<
        "load_6_is_currently_off";
    bm_os << "\n   [" << bm.bool_indicator( bm.load_7_is_currently_off() ) << "] " <<
        "load_7_is_currently_off";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmMiscInputs : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmMiscInputs const & bm);

public:
    explicit BmMiscInputs() : CmdFieldBitmap<2>{} {};
    bool const ac_ok() const {return this -> data_.test(0);}
    bool const input_spare_1() const {return this -> data_.test(1);}
    bool const input_spare_2() const {return this -> data_.test(2);}
    bool const analog_fault() const {return this -> data_.test(3);}
    bool const main_power() const {return this -> data_.test(4);}
    bool const analog_power() const {return this -> data_.test(6);}
    bool const trigger() const {return this -> data_.test(7);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmMiscInputs const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.ac_ok() ) << "] " <<
        "ac_ok";
    bm_os << "\n   [" << bm.bool_indicator( bm.input_spare_1() ) << "] " <<
        "input_spare_1";
    bm_os << "\n   [" << bm.bool_indicator( bm.input_spare_2() ) << "] " <<
        "input_spare_2";
    bm_os << "\n   [" << bm.bool_indicator( bm.analog_fault() ) << "] " <<
        "analog_fault";
    bm_os << "\n   [" << bm.bool_indicator( bm.main_power() ) << "] " <<
        "main_power";
    bm_os << "\n   [" << bm.bool_indicator( bm.analog_power() ) << "] " <<
        "analog_power";
    bm_os << "\n   [" << bm.bool_indicator( bm.trigger() ) << "] " <<
        "trigger";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmPllState : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmPllState const & bm);

public:
    explicit BmPllState() : CmdFieldBitmap<2>{} {};

    enum class PllStatus {
        pll_not_enabled = 0,
        pll_hold = 1,
        pll_tracking = 2,
        pll_locked = 3,
    };

    PllStatus const pll_status() const {return static_cast<PllStatus>( CmdFieldBitmap<2>::raw_value_from_range(6, 0x3) );}
};

//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmPllState::PllStatus const & bmc) {
    using PllStatus = BmPllState::PllStatus;
    bm_os << "\n   pll_status : ";
    switch(bmc) {

    case PllStatus::pll_not_enabled : {
         bm_os << "pll_not_enabled";
         break;}

    case PllStatus::pll_hold : {
         bm_os << "pll_hold";
         break;}

    case PllStatus::pll_tracking : {
         bm_os << "pll_tracking";
         break;}

    case PllStatus::pll_locked : {
         bm_os << "pll_locked";
         break;}
    } // end switch
    return bm_os;
}
inline std::ostream & operator<<(std::ostream & bm_os, BmPllState const & bm) {
    bm_os << "\n";
    bm_os << bm.pll_status();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmProcessorid : public CmdFieldBitmap<4> {

friend std::ostream & operator<<(std::ostream & bm_os, BmProcessorid const & bm);

public:
    explicit BmProcessorid() : CmdFieldBitmap<4>{} {};
    const unsigned long architecture_revision() const {return CmdFieldBitmap<4>::raw_value_from_range(10, 0x7);}
    const unsigned long architecture_type() const {return CmdFieldBitmap<4>::raw_value_from_range(13, 0x7);}
    const unsigned long processor_revision() const {return CmdFieldBitmap<4>::raw_value_from_range(16, 0xF);}
    const unsigned long processor_type() const {return CmdFieldBitmap<4>::raw_value_from_range(24, 0xFF);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmProcessorid const & bm) {
    bm_os << "\n";
    bm_os << "\n   architecture_revision : " << bm.architecture_revision();
    bm_os << "\n   architecture_type : " << bm.architecture_type();
    bm_os << "\n   processor_revision : " << bm.processor_revision();
    bm_os << "\n   processor_type : " << bm.processor_type();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmRqstat : public CmdFieldBitmap<4> {

friend std::ostream & operator<<(std::ostream & bm_os, BmRqstat const & bm);

public:
    explicit BmRqstat() : CmdFieldBitmap<4>{} {};
    bool const global_status() const {return this -> data_.test(0);}
    bool const gps_status() const {return this -> data_.test(1);}
    bool const power_supply_status() const {return this -> data_.test(2);}
    bool const boom_positions() const {return this -> data_.test(3);}
    bool const thread_status() const {return this -> data_.test(4);}
    bool const pll_status() const {return this -> data_.test(5);}
    bool const gps_satellites() const {return this -> data_.test(6);}
    bool const arp_status() const {return this -> data_.test(7);}
    bool const data_port_1_status() const {return this -> data_.test(8);}
    bool const data_port_2_status() const {return this -> data_.test(9);}
    bool const data_port_3_status() const {return this -> data_.test(10);}
    bool const data_port_4_status() const {return this -> data_.test(11);}
    bool const serial_interface_1_status() const {return this -> data_.test(12);}
    bool const serial_interface_2_status() const {return this -> data_.test(13);}
    bool const serial_interface_3_status() const {return this -> data_.test(14);}
    bool const ethernet_status() const {return this -> data_.test(15);}
    bool const baler_status() const {return this -> data_.test(16);}
    bool const dynamic_ip() const {return this -> data_.test(17);}
    bool const auxiliary_board_status() const {return this -> data_.test(18);}
    bool const serial_sensor_status() const {return this -> data_.test(19);}
    bool const environmental_processor_status() const {return this -> data_.test(20);}
    void global_status(const bool b) {this -> data_.set(0, b);}
    void gps_status(const bool b) {this -> data_.set(1, b);}
    void power_supply_status(const bool b) {this -> data_.set(2, b);}
    void boom_positions(const bool b) {this -> data_.set(3, b);}
    void thread_status(const bool b) {this -> data_.set(4, b);}
    void pll_status(const bool b) {this -> data_.set(5, b);}
    void gps_satellites(const bool b) {this -> data_.set(6, b);}
    void arp_status(const bool b) {this -> data_.set(7, b);}
    void data_port_1_status(const bool b) {this -> data_.set(8, b);}
    void data_port_2_status(const bool b) {this -> data_.set(9, b);}
    void data_port_3_status(const bool b) {this -> data_.set(10, b);}
    void data_port_4_status(const bool b) {this -> data_.set(11, b);}
    void serial_interface_1_status(const bool b) {this -> data_.set(12, b);}
    void serial_interface_2_status(const bool b) {this -> data_.set(13, b);}
    void serial_interface_3_status(const bool b) {this -> data_.set(14, b);}
    void ethernet_status(const bool b) {this -> data_.set(15, b);}
    void baler_status(const bool b) {this -> data_.set(16, b);}
    void dynamic_ip(const bool b) {this -> data_.set(17, b);}
    void auxiliary_board_status(const bool b) {this -> data_.set(18, b);}
    void serial_sensor_status(const bool b) {this -> data_.set(19, b);}
    void environmental_processor_status(const bool b) {this -> data_.set(20, b);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmRqstat const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.global_status() ) << "] " <<
        "global_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.gps_status() ) << "] " <<
        "gps_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.power_supply_status() ) << "] " <<
        "power_supply_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.boom_positions() ) << "] " <<
        "boom_positions";
    bm_os << "\n   [" << bm.bool_indicator( bm.thread_status() ) << "] " <<
        "thread_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.pll_status() ) << "] " <<
        "pll_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.gps_satellites() ) << "] " <<
        "gps_satellites";
    bm_os << "\n   [" << bm.bool_indicator( bm.arp_status() ) << "] " <<
        "arp_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.data_port_1_status() ) << "] " <<
        "data_port_1_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.data_port_2_status() ) << "] " <<
        "data_port_2_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.data_port_3_status() ) << "] " <<
        "data_port_3_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.data_port_4_status() ) << "] " <<
        "data_port_4_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.serial_interface_1_status() ) << "] " <<
        "serial_interface_1_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.serial_interface_2_status() ) << "] " <<
        "serial_interface_2_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.serial_interface_3_status() ) << "] " <<
        "serial_interface_3_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.ethernet_status() ) << "] " <<
        "ethernet_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.baler_status() ) << "] " <<
        "baler_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.dynamic_ip() ) << "] " <<
        "dynamic_ip";
    bm_os << "\n   [" << bm.bool_indicator( bm.auxiliary_board_status() ) << "] " <<
        "auxiliary_board_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.serial_sensor_status() ) << "] " <<
        "serial_sensor_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.environmental_processor_status() ) << "] " <<
        "environmental_processor_status";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmSdidriver : public CmdFieldBitmap<1> {

friend std::ostream & operator<<(std::ostream & bm_os, BmSdidriver const & bm);

public:
    explicit BmSdidriver() : CmdFieldBitmap<1>{} {};

    enum class SdiDriver {
        vaisala_wxt520_weather_station = 1,
    };

    SdiDriver const sdi_driver() const {return static_cast<SdiDriver>( CmdFieldBitmap<1>::raw_value() );}
};

//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmSdidriver::SdiDriver const & bmc) {
    using SdiDriver = BmSdidriver::SdiDriver;
    bm_os << "\n   sdi_driver : ";
    switch(bmc) {

    case SdiDriver::vaisala_wxt520_weather_station : {
         bm_os << "vaisala_wxt520_weather_station";
         break;}
    } // end switch
    return bm_os;
}
inline std::ostream & operator<<(std::ostream & bm_os, BmSdidriver const & bm) {
    bm_os << "\n";
    bm_os << bm.sdi_driver();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmSdiphase : public CmdFieldBitmap<1> {

friend std::ostream & operator<<(std::ostream & bm_os, BmSdiphase const & bm);

public:
    explicit BmSdiphase() : CmdFieldBitmap<1>{} {};

    enum class SdiPhase {
        ready_to_run = 6,
        sampling = 7,
        waiting_for_sample_result = 8,
    };

    SdiPhase const sdi_phase() const {return static_cast<SdiPhase>( CmdFieldBitmap<1>::raw_value() );}
};

//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmSdiphase::SdiPhase const & bmc) {
    using SdiPhase = BmSdiphase::SdiPhase;
    bm_os << "\n   sdi_phase : ";
    switch(bmc) {

    case SdiPhase::ready_to_run : {
         bm_os << "ready_to_run";
         break;}

    case SdiPhase::sampling : {
         bm_os << "sampling";
         break;}

    case SdiPhase::waiting_for_sample_result : {
         bm_os << "waiting_for_sample_result";
         break;}
    } // end switch
    return bm_os;
}
inline std::ostream & operator<<(std::ostream & bm_os, BmSdiphase const & bm) {
    bm_os << "\n";
    bm_os << bm.sdi_phase();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmSeedHeaderActivityFlags : public CmdFieldBitmap<1> {

friend std::ostream & operator<<(std::ostream & bm_os, BmSeedHeaderActivityFlags const & bm);

public:
    explicit BmSeedHeaderActivityFlags() : CmdFieldBitmap<1>{} {};
    bool const calibration_signals_present() const {return this -> data_.test(0);}
    bool const time_correction_applied() const {return this -> data_.test(1);}
    bool const beginning_of_an_event() const {return this -> data_.test(2);}
    bool const end_of_an_event() const {return this -> data_.test(3);}
    bool const positive_leap_second_happened() const {return this -> data_.test(4);}
    bool const negative_leap_second_happened() const {return this -> data_.test(5);}
    bool const event_in_progress() const {return this -> data_.test(6);}
    void calibration_signals_present(const bool b) {this -> data_.set(0, b);}
    void time_correction_applied(const bool b) {this -> data_.set(1, b);}
    void beginning_of_an_event(const bool b) {this -> data_.set(2, b);}
    void end_of_an_event(const bool b) {this -> data_.set(3, b);}
    void positive_leap_second_happened(const bool b) {this -> data_.set(4, b);}
    void negative_leap_second_happened(const bool b) {this -> data_.set(5, b);}
    void event_in_progress(const bool b) {this -> data_.set(6, b);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmSeedHeaderActivityFlags const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.calibration_signals_present() ) << "] " <<
        "calibration_signals_present";
    bm_os << "\n   [" << bm.bool_indicator( bm.time_correction_applied() ) << "] " <<
        "time_correction_applied";
    bm_os << "\n   [" << bm.bool_indicator( bm.beginning_of_an_event() ) << "] " <<
        "beginning_of_an_event";
    bm_os << "\n   [" << bm.bool_indicator( bm.end_of_an_event() ) << "] " <<
        "end_of_an_event";
    bm_os << "\n   [" << bm.bool_indicator( bm.positive_leap_second_happened() ) << "] " <<
        "positive_leap_second_happened";
    bm_os << "\n   [" << bm.bool_indicator( bm.negative_leap_second_happened() ) << "] " <<
        "negative_leap_second_happened";
    bm_os << "\n   [" << bm.bool_indicator( bm.event_in_progress() ) << "] " <<
        "event_in_progress";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmSeedHeaderDataQualityFlags : public CmdFieldBitmap<1> {

friend std::ostream & operator<<(std::ostream & bm_os, BmSeedHeaderDataQualityFlags const & bm);

public:
    explicit BmSeedHeaderDataQualityFlags() : CmdFieldBitmap<1>{} {};
    bool const amplifier_saturation_detected() const {return this -> data_.test(0);}
    bool const digitizer_clipping_detected() const {return this -> data_.test(1);}
    bool const spikes_detected() const {return this -> data_.test(2);}
    bool const glitches_detected() const {return this -> data_.test(3);}
    bool const missing_or_padded_data_present() const {return this -> data_.test(4);}
    bool const telemetry_synchronization_error() const {return this -> data_.test(5);}
    bool const a_digital_filter_may_be_charging() const {return this -> data_.test(6);}
    bool const time_tag_is_questionable() const {return this -> data_.test(7);}
    void amplifier_saturation_detected(const bool b) {this -> data_.set(0, b);}
    void digitizer_clipping_detected(const bool b) {this -> data_.set(1, b);}
    void spikes_detected(const bool b) {this -> data_.set(2, b);}
    void glitches_detected(const bool b) {this -> data_.set(3, b);}
    void missing_or_padded_data_present(const bool b) {this -> data_.set(4, b);}
    void telemetry_synchronization_error(const bool b) {this -> data_.set(5, b);}
    void a_digital_filter_may_be_charging(const bool b) {this -> data_.set(6, b);}
    void time_tag_is_questionable(const bool b) {this -> data_.set(7, b);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmSeedHeaderDataQualityFlags const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.amplifier_saturation_detected() ) << "] " <<
        "amplifier_saturation_detected";
    bm_os << "\n   [" << bm.bool_indicator( bm.digitizer_clipping_detected() ) << "] " <<
        "digitizer_clipping_detected";
    bm_os << "\n   [" << bm.bool_indicator( bm.spikes_detected() ) << "] " <<
        "spikes_detected";
    bm_os << "\n   [" << bm.bool_indicator( bm.glitches_detected() ) << "] " <<
        "glitches_detected";
    bm_os << "\n   [" << bm.bool_indicator( bm.missing_or_padded_data_present() ) << "] " <<
        "missing_or_padded_data_present";
    bm_os << "\n   [" << bm.bool_indicator( bm.telemetry_synchronization_error() ) << "] " <<
        "telemetry_synchronization_error";
    bm_os << "\n   [" << bm.bool_indicator( bm.a_digital_filter_may_be_charging() ) << "] " <<
        "a_digital_filter_may_be_charging";
    bm_os << "\n   [" << bm.bool_indicator( bm.time_tag_is_questionable() ) << "] " <<
        "time_tag_is_questionable";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmSeedHeaderIoAndClockFlags : public CmdFieldBitmap<1> {

friend std::ostream & operator<<(std::ostream & bm_os, BmSeedHeaderIoAndClockFlags const & bm);

public:
    explicit BmSeedHeaderIoAndClockFlags() : CmdFieldBitmap<1>{} {};
    bool const station_volume_parity_error_possibly_present() const {return this -> data_.test(0);}
    bool const long_record_read() const {return this -> data_.test(1);}
    bool const short_record_read() const {return this -> data_.test(2);}
    bool const start_of_time_series() const {return this -> data_.test(3);}
    bool const end_of_time_series() const {return this -> data_.test(4);}
    bool const clocked_locked() const {return this -> data_.test(5);}
    void station_volume_parity_error_possibly_present(const bool b) {this -> data_.set(0, b);}
    void long_record_read(const bool b) {this -> data_.set(1, b);}
    void short_record_read(const bool b) {this -> data_.set(2, b);}
    void start_of_time_series(const bool b) {this -> data_.set(3, b);}
    void end_of_time_series(const bool b) {this -> data_.set(4, b);}
    void clocked_locked(const bool b) {this -> data_.set(5, b);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmSeedHeaderIoAndClockFlags const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.station_volume_parity_error_possibly_present() ) << "] " <<
        "station_volume_parity_error_possibly_present";
    bm_os << "\n   [" << bm.bool_indicator( bm.long_record_read() ) << "] " <<
        "long_record_read";
    bm_os << "\n   [" << bm.bool_indicator( bm.short_record_read() ) << "] " <<
        "short_record_read";
    bm_os << "\n   [" << bm.bool_indicator( bm.start_of_time_series() ) << "] " <<
        "start_of_time_series";
    bm_os << "\n   [" << bm.bool_indicator( bm.end_of_time_series() ) << "] " <<
        "end_of_time_series";
    bm_os << "\n   [" << bm.bool_indicator( bm.clocked_locked() ) << "] " <<
        "clocked_locked";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmSensorControlEnable : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmSensorControlEnable const & bm);

public:
    explicit BmSensorControlEnable() : CmdFieldBitmap<2>{} {};
    bool const output_1() const {return this -> data_.test(0);}
    bool const output_2() const {return this -> data_.test(1);}
    bool const output_3() const {return this -> data_.test(2);}
    bool const output_4() const {return this -> data_.test(3);}
    bool const output_5() const {return this -> data_.test(4);}
    bool const output_6() const {return this -> data_.test(5);}
    bool const output_7() const {return this -> data_.test(6);}
    bool const output_8() const {return this -> data_.test(7);}
    void output_1(const bool b) {this -> data_.set(0, b);}
    void output_2(const bool b) {this -> data_.set(1, b);}
    void output_3(const bool b) {this -> data_.set(2, b);}
    void output_4(const bool b) {this -> data_.set(3, b);}
    void output_5(const bool b) {this -> data_.set(4, b);}
    void output_6(const bool b) {this -> data_.set(5, b);}
    void output_7(const bool b) {this -> data_.set(6, b);}
    void output_8(const bool b) {this -> data_.set(7, b);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmSensorControlEnable const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.output_1() ) << "] " <<
        "output_1";
    bm_os << "\n   [" << bm.bool_indicator( bm.output_2() ) << "] " <<
        "output_2";
    bm_os << "\n   [" << bm.bool_indicator( bm.output_3() ) << "] " <<
        "output_3";
    bm_os << "\n   [" << bm.bool_indicator( bm.output_4() ) << "] " <<
        "output_4";
    bm_os << "\n   [" << bm.bool_indicator( bm.output_5() ) << "] " <<
        "output_5";
    bm_os << "\n   [" << bm.bool_indicator( bm.output_6() ) << "] " <<
        "output_6";
    bm_os << "\n   [" << bm.bool_indicator( bm.output_7() ) << "] " <<
        "output_7";
    bm_os << "\n   [" << bm.bool_indicator( bm.output_8() ) << "] " <<
        "output_8";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmSensorControlOutput : public CmdFieldBitmap<1> {

friend std::ostream & operator<<(std::ostream & bm_os, BmSensorControlOutput const & bm);

public:
    explicit BmSensorControlOutput() : CmdFieldBitmap<1>{} {};

    enum class Line {
        idle = 0,
        sensor_a_calibration = 1,
        sensor_a_centering = 2,
        sensor_a_capacitive_coupling = 3,
        sensor_b_calibration = 4,
        sensor_b_centering = 5,
        sensor_b_capacitive_coupling = 6,
        sensor_a_lock = 7,
        sensor_a_unlock = 8,
        sensor_a_aux_1 = 9,
        sensor_a_aux_2 = 10,
        sensor_b_lock = 11,
        sensor_b_unlock = 12,
        sensor_b_aux_1 = 13,
        sensor_b_aux_2 = 14,
    };

    Line const line() const {return static_cast<Line>( CmdFieldBitmap<1>::raw_value() );}
    void line(Line const c) {this -> data_ = std::bitset<8>( static_cast<unsigned long>(c) );}
};

//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmSensorControlOutput::Line const & bmc) {
    using Line = BmSensorControlOutput::Line;
    bm_os << "\n   line : ";
    switch(bmc) {

    case Line::idle : {
         bm_os << "idle";
         break;}

    case Line::sensor_a_calibration : {
         bm_os << "sensor_a_calibration";
         break;}

    case Line::sensor_a_centering : {
         bm_os << "sensor_a_centering";
         break;}

    case Line::sensor_a_capacitive_coupling : {
         bm_os << "sensor_a_capacitive_coupling";
         break;}

    case Line::sensor_b_calibration : {
         bm_os << "sensor_b_calibration";
         break;}

    case Line::sensor_b_centering : {
         bm_os << "sensor_b_centering";
         break;}

    case Line::sensor_b_capacitive_coupling : {
         bm_os << "sensor_b_capacitive_coupling";
         break;}

    case Line::sensor_a_lock : {
         bm_os << "sensor_a_lock";
         break;}

    case Line::sensor_a_unlock : {
         bm_os << "sensor_a_unlock";
         break;}

    case Line::sensor_a_aux_1 : {
         bm_os << "sensor_a_aux_1";
         break;}

    case Line::sensor_a_aux_2 : {
         bm_os << "sensor_a_aux_2";
         break;}

    case Line::sensor_b_lock : {
         bm_os << "sensor_b_lock";
         break;}

    case Line::sensor_b_unlock : {
         bm_os << "sensor_b_unlock";
         break;}

    case Line::sensor_b_aux_1 : {
         bm_os << "sensor_b_aux_1";
         break;}

    case Line::sensor_b_aux_2 : {
         bm_os << "sensor_b_aux_2";
         break;}
    } // end switch
    return bm_os;
}
inline std::ostream & operator<<(std::ostream & bm_os, BmSensorControlOutput const & bm) {
    bm_os << "\n";
    bm_os << bm.line();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmSerialsensorUnits : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmSerialsensorUnits const & bm);

public:
    explicit BmSerialsensorUnits() : CmdFieldBitmap<2>{} {};

    enum class PressureUnits {
        unknown = 0,
        psi = 1,
        hpa = 2,
        bar = 3,
        kpa = 4,
        mpa = 5,
        in_hg = 6,
        mm_hg = 7,
        m_h2o = 8,
    };

    PressureUnits const pressure_units() const {return static_cast<PressureUnits>( CmdFieldBitmap<2>::raw_value() );}
};

//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmSerialsensorUnits::PressureUnits const & bmc) {
    using PressureUnits = BmSerialsensorUnits::PressureUnits;
    bm_os << "\n   pressure_units : ";
    switch(bmc) {

    case PressureUnits::unknown : {
         bm_os << "unknown";
         break;}

    case PressureUnits::psi : {
         bm_os << "psi";
         break;}

    case PressureUnits::hpa : {
         bm_os << "hpa";
         break;}

    case PressureUnits::bar : {
         bm_os << "bar";
         break;}

    case PressureUnits::kpa : {
         bm_os << "kpa";
         break;}

    case PressureUnits::mpa : {
         bm_os << "mpa";
         break;}

    case PressureUnits::in_hg : {
         bm_os << "in_hg";
         break;}

    case PressureUnits::mm_hg : {
         bm_os << "mm_hg";
         break;}

    case PressureUnits::m_h2o : {
         bm_os << "m_h2o";
         break;}
    } // end switch
    return bm_os;
}
inline std::ostream & operator<<(std::ostream & bm_os, BmSerialsensorUnits const & bm) {
    bm_os << "\n";
    bm_os << bm.pressure_units();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmSerialsensorValidfields : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmSerialsensorValidfields const & bm);

public:
    explicit BmSerialsensorValidfields() : CmdFieldBitmap<2>{} {};
    bool const pressure_measurement_is_valid() const {return this -> data_.test(0);}
    bool const internal_temperature_measurement_is_valid() const {return this -> data_.test(1);}
    bool const humidity_measurement_is_valid() const {return this -> data_.test(2);}
    bool const external_temperature_measurement_is_valid() const {return this -> data_.test(3);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmSerialsensorValidfields const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.pressure_measurement_is_valid() ) << "] " <<
        "pressure_measurement_is_valid";
    bm_os << "\n   [" << bm.bool_indicator( bm.internal_temperature_measurement_is_valid() ) << "] " <<
        "internal_temperature_measurement_is_valid";
    bm_os << "\n   [" << bm.bool_indicator( bm.humidity_measurement_is_valid() ) << "] " <<
        "humidity_measurement_is_valid";
    bm_os << "\n   [" << bm.bool_indicator( bm.external_temperature_measurement_is_valid() ) << "] " <<
        "external_temperature_measurement_is_valid";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmStatCalibratorStatus : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmStatCalibratorStatus const & bm);

public:
    explicit BmStatCalibratorStatus() : CmdFieldBitmap<2>{} {};
    bool const calibration_enable_is_on_this_second() const {return this -> data_.test(0);}
    bool const calibration_signal_is_on_this_second() const {return this -> data_.test(1);}
    bool const calibrator_should_be_generating_a_signal_but_isnt() const {return this -> data_.test(2);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmStatCalibratorStatus const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.calibration_enable_is_on_this_second() ) << "] " <<
        "calibration_enable_is_on_this_second";
    bm_os << "\n   [" << bm.bool_indicator( bm.calibration_signal_is_on_this_second() ) << "] " <<
        "calibration_signal_is_on_this_second";
    bm_os << "\n   [" << bm.bool_indicator( bm.calibrator_should_be_generating_a_signal_but_isnt() ) << "] " <<
        "calibrator_should_be_generating_a_signal_but_isnt";
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmStatClockQuality : public CmdFieldBitmap<2> {

friend std::ostream & operator<<(std::ostream & bm_os, BmStatClockQuality const & bm);

public:
    explicit BmStatClockQuality() : CmdFieldBitmap<2>{} {};

    enum class PllStatus {
        pll_not_enabled = 0,
        pll_hold = 1,
        pll_tracking = 2,
        pll_locked = 3,
    };

    bool const clock_has_ever_had_lock() const {return this -> data_.test(0);}
    bool const clock_currently_has_2d_lock() const {return this -> data_.test(1);}
    bool const clock_currently_has_3d_lock() const {return this -> data_.test(2);}
    bool const clock_currently_has_1d_lock() const {return this -> data_.test(3);}
    bool const timemarks_current_frozen_due_to_filtering() const {return this -> data_.test(4);}
    bool const speculative_lock_based_on_internal_clock() const {return this -> data_.test(5);}
    PllStatus const pll_status() const {return static_cast<PllStatus>( CmdFieldBitmap<2>::raw_value_from_range(6, 0x3) );}
};

//! special operator<< for enum class (codes) in bm
inline std::ostream & operator<<(std::ostream & bm_os, BmStatClockQuality::PllStatus const & bmc) {
    using PllStatus = BmStatClockQuality::PllStatus;
    bm_os << "\n   pll_status : ";
    switch(bmc) {

    case PllStatus::pll_not_enabled : {
         bm_os << "pll_not_enabled";
         break;}

    case PllStatus::pll_hold : {
         bm_os << "pll_hold";
         break;}

    case PllStatus::pll_tracking : {
         bm_os << "pll_tracking";
         break;}

    case PllStatus::pll_locked : {
         bm_os << "pll_locked";
         break;}
    } // end switch
    return bm_os;
}
inline std::ostream & operator<<(std::ostream & bm_os, BmStatClockQuality const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.clock_has_ever_had_lock() ) << "] " <<
        "clock_has_ever_had_lock";
    bm_os << "\n   [" << bm.bool_indicator( bm.clock_currently_has_2d_lock() ) << "] " <<
        "clock_currently_has_2d_lock";
    bm_os << "\n   [" << bm.bool_indicator( bm.clock_currently_has_3d_lock() ) << "] " <<
        "clock_currently_has_3d_lock";
    bm_os << "\n   [" << bm.bool_indicator( bm.clock_currently_has_1d_lock() ) << "] " <<
        "clock_currently_has_1d_lock";
    bm_os << "\n   [" << bm.bool_indicator( bm.timemarks_current_frozen_due_to_filtering() ) << "] " <<
        "timemarks_current_frozen_due_to_filtering";
    bm_os << "\n   [" << bm.bool_indicator( bm.speculative_lock_based_on_internal_clock() ) << "] " <<
        "speculative_lock_based_on_internal_clock";
    bm_os << bm.pll_status();
    bm_os << "\n";
    return bm_os;
}

// -------------------------------------------------------------------------- //
class BmStatStatusBitmap : public CmdFieldBitmap<4> {

friend std::ostream & operator<<(std::ostream & bm_os, BmStatStatusBitmap const & bm);

public:
    explicit BmStatStatusBitmap() : CmdFieldBitmap<4>{} {};
    bool const global_status() const {return this -> data_.test(0);}
    bool const gps_status() const {return this -> data_.test(1);}
    bool const power_supply_status() const {return this -> data_.test(2);}
    bool const boom_positions_temperatures_and_voltages() const {return this -> data_.test(3);}
    bool const thread_status() const {return this -> data_.test(4);}
    bool const pll_status() const {return this -> data_.test(5);}
    bool const gps_satellites() const {return this -> data_.test(6);}
    bool const arp_status() const {return this -> data_.test(7);}
    bool const data_port_1_status() const {return this -> data_.test(8);}
    bool const data_port_2_status() const {return this -> data_.test(9);}
    bool const data_port_3_status() const {return this -> data_.test(10);}
    bool const data_port_4_status() const {return this -> data_.test(11);}
    bool const serial_interface_1_status() const {return this -> data_.test(12);}
    bool const serial_interface_2_status() const {return this -> data_.test(13);}
    bool const serial_interface_3_status() const {return this -> data_.test(14);}
    bool const ethernet_status() const {return this -> data_.test(15);}
    bool const baler_status() const {return this -> data_.test(16);}
    bool const dynamic_ip_addresses() const {return this -> data_.test(17);}
    bool const auxiliary_board_status() const {return this -> data_.test(18);}
    bool const serial_sensor_status() const {return this -> data_.test(19);}
    bool const environmental_processor_status() const {return this -> data_.test(20);}
};

inline std::ostream & operator<<(std::ostream & bm_os, BmStatStatusBitmap const & bm) {
    bm_os << "\n";
    bm_os << "\n   [" << bm.bool_indicator( bm.global_status() ) << "] " <<
        "global_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.gps_status() ) << "] " <<
        "gps_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.power_supply_status() ) << "] " <<
        "power_supply_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.boom_positions_temperatures_and_voltages() ) << "] " <<
        "boom_positions_temperatures_and_voltages";
    bm_os << "\n   [" << bm.bool_indicator( bm.thread_status() ) << "] " <<
        "thread_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.pll_status() ) << "] " <<
        "pll_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.gps_satellites() ) << "] " <<
        "gps_satellites";
    bm_os << "\n   [" << bm.bool_indicator( bm.arp_status() ) << "] " <<
        "arp_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.data_port_1_status() ) << "] " <<
        "data_port_1_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.data_port_2_status() ) << "] " <<
        "data_port_2_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.data_port_3_status() ) << "] " <<
        "data_port_3_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.data_port_4_status() ) << "] " <<
        "data_port_4_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.serial_interface_1_status() ) << "] " <<
        "serial_interface_1_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.serial_interface_2_status() ) << "] " <<
        "serial_interface_2_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.serial_interface_3_status() ) << "] " <<
        "serial_interface_3_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.ethernet_status() ) << "] " <<
        "ethernet_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.baler_status() ) << "] " <<
        "baler_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.dynamic_ip_addresses() ) << "] " <<
        "dynamic_ip_addresses";
    bm_os << "\n   [" << bm.bool_indicator( bm.auxiliary_board_status() ) << "] " <<
        "auxiliary_board_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.serial_sensor_status() ) << "] " <<
        "serial_sensor_status";
    bm_os << "\n   [" << bm.bool_indicator( bm.environmental_processor_status() ) << "] " <<
        "environmental_processor_status";
    bm_os << "\n";
    return bm_os;
}
} // end of namespace
#endif // _MZN_CMD_FIELD_BITMAP_TYPES_H
